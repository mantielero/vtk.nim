## =========================================================================
##
##   Program:   Visualization Toolkit
##   Module:    vtkTableToPolyData.h
##
##   Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
##   All rights reserved.
##   See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
##
##      This software is distributed WITHOUT ANY WARRANTY; without even
##      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##      PURPOSE.  See the above copyright notice for more information.
##
## =========================================================================
## *
##  @class   vtkTableToPolyData
##  @brief   filter used to convert a vtkTable to a vtkPolyData
##  consisting of vertices.
##
##  vtkTableToPolyData is a filter used to convert a vtkTable  to a vtkPolyData
##  consisting of vertices.
##

## !!!Ignored construct:  # vtkTableToPolyData_h [NewLine] # vtkTableToPolyData_h [NewLine] # vtkFiltersGeneralModule.h  For export macro # vtkPolyDataAlgorithm.h [NewLine] class VTKFILTERSGENERAL_EXPORT vtkTableToPolyData : public vtkPolyDataAlgorithm { public : static vtkTableToPolyData * New ( ) ; protected : const char * GetClassNameInternal ( ) const override { return thisClass ; } public : typedef vtkPolyDataAlgorithm Superclass ; static vtkTypeBool IsTypeOf ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 1 ; } return vtkPolyDataAlgorithm :: IsTypeOf ( type ) ; } vtkTypeBool IsA ( const char * type ) override { return this -> vtkTableToPolyData :: IsTypeOf ( type ) ; } static vtkTableToPolyData * SafeDownCast ( vtkObjectBase * o ) { if ( o && o -> IsA ( thisClass ) ) { return static_cast < vtkTableToPolyData * > ( o ) ; } return nullptr ; } VTK_NEWINSTANCE vtkTableToPolyData * NewInstance ( ) const { return vtkTableToPolyData :: SafeDownCast ( this -> NewInstanceInternal ( ) ) ; } static vtkIdType GetNumberOfGenerationsFromBaseType ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 0 ; } return 1 + vtkPolyDataAlgorithm :: GetNumberOfGenerationsFromBaseType ( type ) ; } vtkIdType GetNumberOfGenerationsFromBase ( const char * type ) override { return this -> vtkTableToPolyData :: GetNumberOfGenerationsFromBaseType ( type ) ; } public : protected : vtkObjectBase * NewInstanceInternal ( ) const override { return vtkTableToPolyData :: New ( ) ; } public : ; void PrintSelf ( ostream & os , vtkIndent indent ) override ; /@{ *
##  Set the name of the column to use as the X coordinate for the points.
##  virtual void SetXColumn ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << XColumn  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> XColumn == nullptr && _arg == nullptr ) { return ; } if ( this -> XColumn && _arg && ( ! strcmp ( this -> XColumn , _arg ) ) ) { return ; } delete [ ] this -> XColumn ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> XColumn = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> XColumn = nullptr ; } this -> Modified ( ) ; } ; virtual char * GetXColumn ( ) { vtkDebugWithObjectMacro ( this , <<  returning  << XColumn  of  << ( this -> XColumn ? this -> XColumn : (null) ) ) ; return this -> XColumn ; } ; /@} /@{ *
##  Set the index of the column to use as the X coordinate for the points.
##  virtual void SetXColumnIndex ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << XColumnIndex  to  << _arg ) ; if ( this -> XColumnIndex != ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ) { this -> XColumnIndex = ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetXColumnIndexMinValue ( ) { return 0 ; } virtual int GetXColumnIndexMaxValue ( ) { return VTK_INT_MAX ; } ; virtual int GetXColumnIndex ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << XColumnIndex  of  << this -> XColumnIndex ) ; return this -> XColumnIndex ; } ; /@} /@{ *
##  Specify the component for the column specified using SetXColumn() to
##  use as the xcoordinate in case the column is a multi-component array.
##  Default is 0.
##  virtual void SetXColumnIndexXComponent ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << XComponent  to  << _arg ) ; if ( this -> XComponent != ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ) { this -> XComponent = ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetXColumnIndexMinValueXComponentMinValue ( ) { return 0 ; } virtual int GetXColumnIndexMaxValueXComponentMaxValue ( ) { return VTK_INT_MAX ; } ; virtual int GetXColumnIndexXComponent ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << XComponent  of  << this -> XComponent ) ; return this -> XComponent ; } ; /@} /@{ *
##  Set the name of the column to use as the Y coordinate for the points.
##  Default is 0.
##  virtual void SetXColumnYColumn ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << YColumn  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> YColumn == nullptr && _arg == nullptr ) { return ; } if ( this -> YColumn && _arg && ( ! strcmp ( this -> YColumn , _arg ) ) ) { return ; } delete [ ] this -> YColumn ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> YColumn = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> YColumn = nullptr ; } this -> Modified ( ) ; } ; virtual char * GetXColumnYColumn ( ) { vtkDebugWithObjectMacro ( this , <<  returning  << YColumn  of  << ( this -> YColumn ? this -> YColumn : (null) ) ) ; return this -> YColumn ; } ; /@} /@{ *
##  Set the index of the column to use as the Y coordinate for the points.
##  virtual void SetXColumnIndexXComponentYColumnIndex ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << YColumnIndex  to  << _arg ) ; if ( this -> YColumnIndex != ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ) { this -> YColumnIndex = ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetXColumnIndexMinValueXComponentMinValueYColumnIndexMinValue ( ) { return 0 ; } virtual int GetXColumnIndexMaxValueXComponentMaxValueYColumnIndexMaxValue ( ) { return VTK_INT_MAX ; } ; virtual int GetXColumnIndexXComponentYColumnIndex ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << YColumnIndex  of  << this -> YColumnIndex ) ; return this -> YColumnIndex ; } ; /@} /@{ *
##  Specify the component for the column specified using SetYColumn() to
##  use as the Ycoordinate in case the column is a multi-component array.
##  virtual void SetXColumnIndexXComponentYColumnIndexYComponent ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << YComponent  to  << _arg ) ; if ( this -> YComponent != ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ) { this -> YComponent = ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetXColumnIndexMinValueXComponentMinValueYColumnIndexMinValueYComponentMinValue ( ) { return 0 ; } virtual int GetXColumnIndexMaxValueXComponentMaxValueYColumnIndexMaxValueYComponentMaxValue ( ) { return VTK_INT_MAX ; } ; virtual int GetXColumnIndexXComponentYColumnIndexYComponent ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << YComponent  of  << this -> YComponent ) ; return this -> YComponent ; } ; /@} /@{ *
##  Set the name of the column to use as the Z coordinate for the points.
##  Default is 0.
##  virtual void SetXColumnYColumnZColumn ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << ZColumn  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> ZColumn == nullptr && _arg == nullptr ) { return ; } if ( this -> ZColumn && _arg && ( ! strcmp ( this -> ZColumn , _arg ) ) ) { return ; } delete [ ] this -> ZColumn ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> ZColumn = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> ZColumn = nullptr ; } this -> Modified ( ) ; } ; virtual char * GetXColumnYColumnZColumn ( ) { vtkDebugWithObjectMacro ( this , <<  returning  << ZColumn  of  << ( this -> ZColumn ? this -> ZColumn : (null) ) ) ; return this -> ZColumn ; } ; /@} /@{ *
##  Set the index of the column to use as the Z coordinate for the points.
##  virtual void SetXColumnIndexXComponentYColumnIndexYComponentZColumnIndex ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << ZColumnIndex  to  << _arg ) ; if ( this -> ZColumnIndex != ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ) { this -> ZColumnIndex = ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetXColumnIndexMinValueXComponentMinValueYColumnIndexMinValueYComponentMinValueZColumnIndexMinValue ( ) { return 0 ; } virtual int GetXColumnIndexMaxValueXComponentMaxValueYColumnIndexMaxValueYComponentMaxValueZColumnIndexMaxValue ( ) { return VTK_INT_MAX ; } ; virtual int GetXColumnIndexXComponentYColumnIndexYComponentZColumnIndex ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ZColumnIndex  of  << this -> ZColumnIndex ) ; return this -> ZColumnIndex ; } ; /@} /@{ *
##  Specify the component for the column specified using SetZColumn() to
##  use as the Zcoordinate in case the column is a multi-component array.
##  virtual void SetXColumnIndexXComponentYColumnIndexYComponentZColumnIndexZComponent ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << ZComponent  to  << _arg ) ; if ( this -> ZComponent != ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ) { this -> ZComponent = ( _arg < 0 ? 0 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetXColumnIndexMinValueXComponentMinValueYColumnIndexMinValueYComponentMinValueZColumnIndexMinValueZComponentMinValue ( ) { return 0 ; } virtual int GetXColumnIndexMaxValueXComponentMaxValueYColumnIndexMaxValueYComponentMaxValueZColumnIndexMaxValueZComponentMaxValue ( ) { return VTK_INT_MAX ; } ; virtual int GetXColumnIndexXComponentYColumnIndexYComponentZColumnIndexZComponent ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ZComponent  of  << this -> ZComponent ) ; return this -> ZComponent ; } ; /@} /@{ *
##  Specify whether the points of the polydata are 3D or 2D. If this is set to
##  true then the Z Column will be ignored and the z value of each point on the
##  polydata will be set to 0. By default this will be off.
##  virtual void SetCreate2DPoints ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  Create2DPoints  to  << _arg ) ; if ( this -> Create2DPoints != _arg ) { this -> Create2DPoints = _arg ; this -> Modified ( ) ; } } ; virtual bool GetXColumnIndexXComponentYColumnIndexYComponentZColumnIndexZComponentCreate2DPoints ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << Create2DPoints  of  << this -> Create2DPoints ) ; return this -> Create2DPoints ; } ; virtual void Create2DPointsOn ( ) { this -> SetCreate2DPoints ( static_cast < bool > ( 1 ) ) ; } virtual void Create2DPointsOff ( ) { this -> SetCreate2DPoints ( static_cast < bool > ( 0 ) ) ; } ; /@} /@{ *
##  Allow user to keep columns specified as X,Y,Z as Data arrays.
##  By default this will be off.
##  virtual void SetCreate2DPointsPreserveCoordinateColumnsAsDataArrays ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  PreserveCoordinateColumnsAsDataArrays  to  << _arg ) ; if ( this -> PreserveCoordinateColumnsAsDataArrays != _arg ) { this -> PreserveCoordinateColumnsAsDataArrays = _arg ; this -> Modified ( ) ; } } ; virtual bool GetXColumnIndexXComponentYColumnIndexYComponentZColumnIndexZComponentCreate2DPointsPreserveCoordinateColumnsAsDataArrays ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PreserveCoordinateColumnsAsDataArrays  of  << this -> PreserveCoordinateColumnsAsDataArrays ) ; return this -> PreserveCoordinateColumnsAsDataArrays ; } ; virtual void PreserveCoordinateColumnsAsDataArraysOn ( ) { this -> SetCreate2DPointsPreserveCoordinateColumnsAsDataArrays ( static_cast < bool > ( 1 ) ) ; } virtual void PreserveCoordinateColumnsAsDataArraysOff ( ) { this -> SetCreate2DPointsPreserveCoordinateColumnsAsDataArrays ( static_cast < bool > ( 0 ) ) ; } ; /@} protected : vtkTableToPolyData ( ) ; ~ vtkTableToPolyData ( ) override ; *
##  Overridden to specify that input must be a vtkTable.
##  int FillInputPortInformation ( int port , vtkInformation * info ) override ; *
##  Convert input vtkTable to vtkPolyData.
##  int RequestData ( vtkInformation * request , vtkInformationVector * * inputVector , vtkInformationVector * outputVector ) override ; char * XColumn ; char * YColumn ; char * ZColumn ; int XColumnIndex ; int YColumnIndex ; int ZColumnIndex ; int XComponent ; int YComponent ; int ZComponent ; bool Create2DPoints ; bool PreserveCoordinateColumnsAsDataArrays ; private : vtkTableToPolyData ( const vtkTableToPolyData & ) = delete ; void operator = ( const vtkTableToPolyData & ) = delete ; } ;
## Error: token expected: ; but got: [identifier]!!!
