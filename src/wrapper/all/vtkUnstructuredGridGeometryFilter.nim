## =========================================================================
##
##   Program:   Visualization Toolkit
##   Module:    vtkUnstructuredGridGeometryFilter.h
##
##   Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
##   All rights reserved.
##   See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
##
##      This software is distributed WITHOUT ANY WARRANTY; without even
##      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##      PURPOSE.  See the above copyright notice for more information.
##
## =========================================================================
## *
##  @class   vtkUnstructuredGridGeometryFilter
##  @brief   extract geometry from an unstructured grid
##
##  vtkUnstructuredGridGeometryFilter is a filter that extracts
##  geometry (and associated data) from an unstructured grid. It differs from
##  vtkGeometryFilter by not tessellating higher order faces: 2D faces of
##  quadratic 3D cells will be quadratic. A quadratic edge is extracted as a
##  quadratic edge. For that purpose, the output of this filter is an
##  unstructured grid, not a polydata.
##  Also, the face of a voxel is a pixel, not a quad.
##  Geometry is obtained as follows: all 0D, 1D, and 2D cells are extracted.
##  All 2D faces that are used by only one 3D cell (i.e., boundary faces) are
##  extracted. It also is possible to specify conditions on point ids, cell ids,
##  and on bounding box (referred to as "Extent") to control the extraction
##  process.
##
##  @warning
##  When vtkUnstructuredGridGeometryFilter extracts cells (or boundaries of
##  cells) it will (by default) merge duplicate vertices. This may cause
##  problems in some cases. Turn merging off to prevent this from occurring.
##
##  @sa
##  vtkGeometryFilter vtkDataSetSurfaceFilter
##

## !!!Ignored construct:  # vtkUnstructuredGridGeometryFilter_h [NewLine] # vtkUnstructuredGridGeometryFilter_h [NewLine] # vtkFiltersGeometryModule.h  For export macro # vtkUnstructuredGridBaseAlgorithm.h [NewLine] class vtkIncrementalPointLocator ;
## Error: token expected: ; but got: [identifier]!!!

discard "forward decl of vtkHashTableOfSurfels"
## !!!Ignored construct:  class VTKFILTERSGEOMETRY_EXPORT vtkUnstructuredGridGeometryFilter : public vtkUnstructuredGridBaseAlgorithm { public : static vtkUnstructuredGridGeometryFilter * New ( ) ; protected : const char * GetClassNameInternal ( ) const override { return thisClass ; } public : typedef vtkUnstructuredGridBaseAlgorithm Superclass ; static vtkTypeBool IsTypeOf ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 1 ; } return vtkUnstructuredGridBaseAlgorithm :: IsTypeOf ( type ) ; } vtkTypeBool IsA ( const char * type ) override { return this -> vtkUnstructuredGridGeometryFilter :: IsTypeOf ( type ) ; } static vtkUnstructuredGridGeometryFilter * SafeDownCast ( vtkObjectBase * o ) { if ( o && o -> IsA ( thisClass ) ) { return static_cast < vtkUnstructuredGridGeometryFilter * > ( o ) ; } return nullptr ; } VTK_NEWINSTANCE vtkUnstructuredGridGeometryFilter * NewInstance ( ) const { return vtkUnstructuredGridGeometryFilter :: SafeDownCast ( this -> NewInstanceInternal ( ) ) ; } static vtkIdType GetNumberOfGenerationsFromBaseType ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 0 ; } return 1 + vtkUnstructuredGridBaseAlgorithm :: GetNumberOfGenerationsFromBaseType ( type ) ; } vtkIdType GetNumberOfGenerationsFromBase ( const char * type ) override { return this -> vtkUnstructuredGridGeometryFilter :: GetNumberOfGenerationsFromBaseType ( type ) ; } public : protected : vtkObjectBase * NewInstanceInternal ( ) const override { return vtkUnstructuredGridGeometryFilter :: New ( ) ; } public : ; void PrintSelf ( ostream & os , vtkIndent indent ) override ; /@{ *
##  Turn on/off selection of geometry by point id.
##  virtual void SetPointClipping ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  PointClipping  to  << _arg ) ; if ( this -> PointClipping != _arg ) { this -> PointClipping = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPointClipping ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PointClipping  of  << this -> PointClipping ) ; return this -> PointClipping ; } ; virtual void PointClippingOn ( ) { this -> SetPointClipping ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void PointClippingOff ( ) { this -> SetPointClipping ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Turn on/off selection of geometry by cell id.
##  virtual void SetPointClippingCellClipping ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  CellClipping  to  << _arg ) ; if ( this -> CellClipping != _arg ) { this -> CellClipping = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPointClippingCellClipping ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << CellClipping  of  << this -> CellClipping ) ; return this -> CellClipping ; } ; virtual void CellClippingOn ( ) { this -> SetPointClippingCellClipping ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void CellClippingOff ( ) { this -> SetPointClippingCellClipping ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Turn on/off selection of geometry via bounding box.
##  virtual void SetPointClippingCellClippingExtentClipping ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  ExtentClipping  to  << _arg ) ; if ( this -> ExtentClipping != _arg ) { this -> ExtentClipping = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPointClippingCellClippingExtentClipping ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ExtentClipping  of  << this -> ExtentClipping ) ; return this -> ExtentClipping ; } ; virtual void ExtentClippingOn ( ) { this -> SetPointClippingCellClippingExtentClipping ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void ExtentClippingOff ( ) { this -> SetPointClippingCellClippingExtentClipping ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Turn on/off clipping of ghost cells with type
##  vtkDataSetAttributes::DUPLICATECELL. Defaults to on.
##  virtual void SetPointClippingCellClippingExtentClippingDuplicateGhostCellClipping ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  DuplicateGhostCellClipping  to  << _arg ) ; if ( this -> DuplicateGhostCellClipping != _arg ) { this -> DuplicateGhostCellClipping = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPointClippingCellClippingExtentClippingDuplicateGhostCellClipping ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << DuplicateGhostCellClipping  of  << this -> DuplicateGhostCellClipping ) ; return this -> DuplicateGhostCellClipping ; } ; virtual void DuplicateGhostCellClippingOn ( ) { this -> SetPointClippingCellClippingExtentClippingDuplicateGhostCellClipping ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void DuplicateGhostCellClippingOff ( ) { this -> SetPointClippingCellClippingExtentClippingDuplicateGhostCellClipping ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Specify the minimum point id for point id selection.
##  virtual void SetPointMinimum ( vtkIdType _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << PointMinimum  to  << _arg ) ; if ( this -> PointMinimum != ( _arg < 0 ? 0 : ( _arg > VTK_ID_MAX ? VTK_ID_MAX : _arg ) ) ) { this -> PointMinimum = ( _arg < 0 ? 0 : ( _arg > VTK_ID_MAX ? VTK_ID_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual vtkIdType GetPointMinimumMinValue ( ) { return 0 ; } virtual vtkIdType GetPointMinimumMaxValue ( ) { return VTK_ID_MAX ; } ; virtual vtkIdType GetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingPointMinimum ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PointMinimum  of  << this -> PointMinimum ) ; return this -> PointMinimum ; } ; /@} /@{ *
##  Specify the maximum point id for point id selection.
##  virtual void SetPointMinimumPointMaximum ( vtkIdType _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << PointMaximum  to  << _arg ) ; if ( this -> PointMaximum != ( _arg < 0 ? 0 : ( _arg > VTK_ID_MAX ? VTK_ID_MAX : _arg ) ) ) { this -> PointMaximum = ( _arg < 0 ? 0 : ( _arg > VTK_ID_MAX ? VTK_ID_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual vtkIdType GetPointMinimumMinValuePointMaximumMinValue ( ) { return 0 ; } virtual vtkIdType GetPointMinimumMaxValuePointMaximumMaxValue ( ) { return VTK_ID_MAX ; } ; virtual vtkIdType GetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingPointMinimumPointMaximum ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PointMaximum  of  << this -> PointMaximum ) ; return this -> PointMaximum ; } ; /@} /@{ *
##  Specify the minimum cell id for point id selection.
##  virtual void SetPointMinimumPointMaximumCellMinimum ( vtkIdType _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << CellMinimum  to  << _arg ) ; if ( this -> CellMinimum != ( _arg < 0 ? 0 : ( _arg > VTK_ID_MAX ? VTK_ID_MAX : _arg ) ) ) { this -> CellMinimum = ( _arg < 0 ? 0 : ( _arg > VTK_ID_MAX ? VTK_ID_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual vtkIdType GetPointMinimumMinValuePointMaximumMinValueCellMinimumMinValue ( ) { return 0 ; } virtual vtkIdType GetPointMinimumMaxValuePointMaximumMaxValueCellMinimumMaxValue ( ) { return VTK_ID_MAX ; } ; virtual vtkIdType GetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingPointMinimumPointMaximumCellMinimum ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << CellMinimum  of  << this -> CellMinimum ) ; return this -> CellMinimum ; } ; /@} /@{ *
##  Specify the maximum cell id for point id selection.
##  virtual void SetPointMinimumPointMaximumCellMinimumCellMaximum ( vtkIdType _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << CellMaximum  to  << _arg ) ; if ( this -> CellMaximum != ( _arg < 0 ? 0 : ( _arg > VTK_ID_MAX ? VTK_ID_MAX : _arg ) ) ) { this -> CellMaximum = ( _arg < 0 ? 0 : ( _arg > VTK_ID_MAX ? VTK_ID_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual vtkIdType GetPointMinimumMinValuePointMaximumMinValueCellMinimumMinValueCellMaximumMinValue ( ) { return 0 ; } virtual vtkIdType GetPointMinimumMaxValuePointMaximumMaxValueCellMinimumMaxValueCellMaximumMaxValue ( ) { return VTK_ID_MAX ; } ; virtual vtkIdType GetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingPointMinimumPointMaximumCellMinimumCellMaximum ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << CellMaximum  of  << this -> CellMaximum ) ; return this -> CellMaximum ; } ; /@} *
##  Specify a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to clip data.
##  void SetExtent ( double xMin , double xMax , double yMin , double yMax , double zMin , double zMax ) ; /@{ *
##  Set / get a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to clip data.
##  void SetExtent ( double extent [ 6 ] ) ; double * GetExtent ( ) { return this -> Extent ; } /@} /@{ *
##  Turn on/off merging of coincident points. Note that is merging is
##  on, points with different point attributes (e.g., normals) are merged,
##  which may cause rendering artifacts.
##  virtual void SetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingMerging ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  Merging  to  << _arg ) ; if ( this -> Merging != _arg ) { this -> Merging = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingPointMinimumPointMaximumCellMinimumCellMaximumMerging ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << Merging  of  << this -> Merging ) ; return this -> Merging ; } ; virtual void MergingOn ( ) { this -> SetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingMerging ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void MergingOff ( ) { this -> SetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingMerging ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  If on, the output polygonal dataset will have a celldata array that
##  holds the cell index of the original 3D cell that produced each output
##  cell. This is useful for cell picking. The default is off to conserve
##  memory. Note that PassThroughCellIds will be ignored if UseStrips is on,
##  since in that case each tringle strip can represent more than on of the
##  input cells.
##  virtual void SetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingMergingPassThroughCellIds ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  PassThroughCellIds  to  << _arg ) ; if ( this -> PassThroughCellIds != _arg ) { this -> PassThroughCellIds = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingPointMinimumPointMaximumCellMinimumCellMaximumMergingPassThroughCellIds ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PassThroughCellIds  of  << this -> PassThroughCellIds ) ; return this -> PassThroughCellIds ; } ; virtual void PassThroughCellIdsOn ( ) { this -> SetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingMergingPassThroughCellIds ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void PassThroughCellIdsOff ( ) { this -> SetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingMergingPassThroughCellIds ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; virtual void SetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingMergingPassThroughCellIdsPassThroughPointIds ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  PassThroughPointIds  to  << _arg ) ; if ( this -> PassThroughPointIds != _arg ) { this -> PassThroughPointIds = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingPointMinimumPointMaximumCellMinimumCellMaximumMergingPassThroughCellIdsPassThroughPointIds ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PassThroughPointIds  of  << this -> PassThroughPointIds ) ; return this -> PassThroughPointIds ; } ; virtual void PassThroughPointIdsOn ( ) { this -> SetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingMergingPassThroughCellIdsPassThroughPointIds ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void PassThroughPointIdsOff ( ) { this -> SetPointClippingCellClippingExtentClippingDuplicateGhostCellClippingMergingPassThroughCellIdsPassThroughPointIds ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  If PassThroughCellIds or PassThroughPointIds is on, then these ivars
##  control the name given to the field in which the ids are written into.  If
##  set to nullptr, then vtkOriginalCellIds or vtkOriginalPointIds (the default)
##  is used, respectively.
##  virtual void SetOriginalCellIdsName ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << OriginalCellIdsName  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> OriginalCellIdsName == nullptr && _arg == nullptr ) { return ; } if ( this -> OriginalCellIdsName && _arg && ( ! strcmp ( this -> OriginalCellIdsName , _arg ) ) ) { return ; } delete [ ] this -> OriginalCellIdsName ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> OriginalCellIdsName = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> OriginalCellIdsName = nullptr ; } this -> Modified ( ) ; } ; virtual const char * GetOriginalCellIdsName ( ) { return ( this -> OriginalCellIdsName ? this -> OriginalCellIdsName : vtkOriginalCellIds ) ; } virtual void SetOriginalCellIdsNameOriginalPointIdsName ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << OriginalPointIdsName  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> OriginalPointIdsName == nullptr && _arg == nullptr ) { return ; } if ( this -> OriginalPointIdsName && _arg && ( ! strcmp ( this -> OriginalPointIdsName , _arg ) ) ) { return ; } delete [ ] this -> OriginalPointIdsName ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> OriginalPointIdsName = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> OriginalPointIdsName = nullptr ; } this -> Modified ( ) ; } ; virtual const char * GetOriginalPointIdsName ( ) { return ( this -> OriginalPointIdsName ? this -> OriginalPointIdsName : vtkOriginalPointIds ) ; } /@} /@{ *
##  Set / get a spatial locator for merging points. By
##  default an instance of vtkMergePoints is used.
##  void SetLocator ( vtkIncrementalPointLocator * locator ) ; virtual vtkIncrementalPointLocator * GetnameLocator ( ) { vtkDebugWithObjectMacro ( this , <<  returning  Locator  address  << static_cast < vtkIncrementalPointLocator * > ( this -> Locator ) ) ; return this -> Locator ; } ; /@} *
##  Create default locator. Used to create one when none is specified.
##  void CreateDefaultLocator ( ) ; *
##  Return the MTime also considering the locator.
##  vtkMTimeType GetMTime ( ) override ; protected : vtkUnstructuredGridGeometryFilter ( ) ; ~ vtkUnstructuredGridGeometryFilter ( ) override ; int RequestData ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; int FillInputPortInformation ( int port , vtkInformation * info ) override ; int RequestUpdateExtent ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; vtkIdType PointMaximum ; vtkIdType PointMinimum ; vtkIdType CellMinimum ; vtkIdType CellMaximum ; double Extent [ 6 ] ; vtkTypeBool PointClipping ; vtkTypeBool CellClipping ; vtkTypeBool ExtentClipping ; vtkTypeBool DuplicateGhostCellClipping ; vtkTypeBool PassThroughCellIds ; vtkTypeBool PassThroughPointIds ; char * OriginalCellIdsName ; char * OriginalPointIdsName ; vtkTypeBool Merging ; vtkIncrementalPointLocator * Locator ; vtkHashTableOfSurfels * HashTable ; private : vtkUnstructuredGridGeometryFilter ( const vtkUnstructuredGridGeometryFilter & ) = delete ; void operator = ( const vtkUnstructuredGridGeometryFilter & ) = delete ; } ;
## Error: token expected: ; but got: [identifier]!!!
