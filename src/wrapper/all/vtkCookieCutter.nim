## =========================================================================
##
##   Program:   Visualization Toolkit
##   Module:    vtkCookieCutter.h
##
##   Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
##   All rights reserved.
##   See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
##
##      This software is distributed WITHOUT ANY WARRANTY; without even
##      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##      PURPOSE.  See the above copyright notice for more information.
##
## =========================================================================
## *
##  @class   vtkCookieCutter
##  @brief   cut vtkPolyData defined on the 2D plane with one or more polygons
##
##  This filter crops an input vtkPolyData consisting of cells (i.e., points,
##  lines, polygons, and triangle strips) with trim loops specified by a second
##  input containing polygons and/or polylines. The input vtkPolyData and the
##  loops must lie on the same plane. Note that this filter can handle concave
##  polygons and/or loops. It may produce multiple output polygons for each
##  polygon/loop interaction. Similarly, it may produce multiple line segments
##  and so on. (The input to cookie cut (input0) is referred to as the input
##  mesh, while the loops used to cut the input mesh (input1) are referred to
##  as the trim loops.)
##
##  The filter has the option to pass through and generate point and cell
##  data.  If PassCellData is enabled, then the cell data associated with the
##  cropped cells, or cells passed through from the input mesh, are passed
##  through to the output. If PassPointData is enabled, then in similar
##  fashion the point data is passed through; however new points generated by
##  intersection may have point data interpolated in one of two ways. First,
##  the input mesh edges are interpolated at the new intersection points to
##  generate point data, or the trim loop edges are interpolated at the new
##  intersection points to generate point data. Note: for PassPointData and
##  point interpolation to function, the filter requires that the point data
##  attributes (from the mesh and trim loop) are exactly the same. If they are
##  not, then a set intersection operation is performed which uses the point
##  data arrays common to both the mesh and trim loops.
##
##  @warning
##  The mesh and trim loops must lie on the same plane and the plane may be
##  arbitrarily oriented. If not on the same plane, tolerancing issues can
##  produce erratic results.
##
##  @sa
##  vtkImprintFilter
##

## !!!Ignored construct:  # vtkCookieCutter_h [NewLine] # vtkCookieCutter_h [NewLine] # vtkFiltersModelingModule.h  For export macro # vtkPolyDataAlgorithm.h [NewLine] class VTKFILTERSMODELING_EXPORT vtkCookieCutter : public vtkPolyDataAlgorithm { public : /@{ *
##  Standard methods to instantiate, print and provide type information.
##  static vtkCookieCutter * New ( ) ; protected : const char * GetClassNameInternal ( ) const override { return thisClass ; } public : typedef vtkPolyDataAlgorithm Superclass ; static vtkTypeBool IsTypeOf ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 1 ; } return vtkPolyDataAlgorithm :: IsTypeOf ( type ) ; } vtkTypeBool IsA ( const char * type ) override { return this -> vtkCookieCutter :: IsTypeOf ( type ) ; } static vtkCookieCutter * SafeDownCast ( vtkObjectBase * o ) { if ( o && o -> IsA ( thisClass ) ) { return static_cast < vtkCookieCutter * > ( o ) ; } return nullptr ; } VTK_NEWINSTANCE vtkCookieCutter * NewInstance ( ) const { return vtkCookieCutter :: SafeDownCast ( this -> NewInstanceInternal ( ) ) ; } static vtkIdType GetNumberOfGenerationsFromBaseType ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 0 ; } return 1 + vtkPolyDataAlgorithm :: GetNumberOfGenerationsFromBaseType ( type ) ; } vtkIdType GetNumberOfGenerationsFromBase ( const char * type ) override { return this -> vtkCookieCutter :: GetNumberOfGenerationsFromBaseType ( type ) ; } public : protected : vtkObjectBase * NewInstanceInternal ( ) const override { return vtkCookieCutter :: New ( ) ; } public : ; void PrintSelf ( ostream & os , vtkIndent indent ) override ; /@} *
##  Specify the a second vtkPolyData input which defines trim loops used to
##  cut the input polygonal data. These loops must be manifold, i.e., do not
##  self intersect. The loops are defined from the polygons and polylines
##  defined in this second input. Note that if polylines are used, they are
##  assumed to be closed.
##  void SetLoopsConnection ( vtkAlgorithmOutput * algOutput ) ; vtkAlgorithmOutput * GetLoopsConnection ( ) ; /@{ *
##  Specify the a second vtkPolyData input which defines trim loops used to
##  cut the input polygonal data. These loops must be manifold, i.e., do not
##  self intersect. The loops are defined from the polygons and polylines
##  defined in this second input.
##  void SetLoopsData ( vtkDataObject * loops ) ; vtkDataObject * GetLoops ( ) ; /@} /@{ *
##  Indicate whether cell data from the input mesh is to be passed through
##  to the output mesh. By default, PassCellData is enabled.
##  virtual void SetPassCellData ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  PassCellData  to  << _arg ) ; if ( this -> PassCellData != _arg ) { this -> PassCellData = _arg ; this -> Modified ( ) ; } } ; virtual bool GetPassCellData ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PassCellData  of  << this -> PassCellData ) ; return this -> PassCellData ; } ; virtual void PassCellDataOn ( ) { this -> SetPassCellData ( static_cast < bool > ( 1 ) ) ; } virtual void PassCellDataOff ( ) { this -> SetPassCellData ( static_cast < bool > ( 0 ) ) ; } ; /@} /@{ *
##  Indicate whether point data from the input mesh are to be passed through
##  and/or interpolated to the output mesh. By default, PassPointData is
##  enabled. Note: both the input mesh points and the trim
##  loops, must have identical point data. Otherwise, a set operation will
##  be performed to process just the point data arrays common to both the
##  mesh point data and loops point data.
##  virtual void SetPassCellDataPassPointData ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  PassPointData  to  << _arg ) ; if ( this -> PassPointData != _arg ) { this -> PassPointData = _arg ; this -> Modified ( ) ; } } ; virtual bool GetPassCellDataPassPointData ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PassPointData  of  << this -> PassPointData ) ; return this -> PassPointData ; } ; virtual void PassPointDataOn ( ) { this -> SetPassCellDataPassPointData ( static_cast < bool > ( 1 ) ) ; } virtual void PassPointDataOff ( ) { this -> SetPassCellDataPassPointData ( static_cast < bool > ( 0 ) ) ; } ; /@} enum PointInterpolationType { USE_MESH_EDGES = 0 , USE_LOOP_EDGES = 1 } ; /@{ *
##  If PassPointData is on, indicate how new point data is to generated at
##  the intersection points between the input mesh edges and the trim edges
##  (trim edges form the loops). By default, PointInterpolation is set to
##  USE_MESH_EDGES.
##  virtual void SetPointInterpolation ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << PointInterpolation  to  << _arg ) ; if ( this -> PointInterpolation != ( _arg < USE_MESH_EDGES ? USE_MESH_EDGES : ( _arg > USE_LOOP_EDGES ? USE_LOOP_EDGES : _arg ) ) ) { this -> PointInterpolation = ( _arg < USE_MESH_EDGES ? USE_MESH_EDGES : ( _arg > USE_LOOP_EDGES ? USE_LOOP_EDGES : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetPointInterpolationMinValue ( ) { return USE_MESH_EDGES ; } virtual int GetPointInterpolationMaxValue ( ) { return USE_LOOP_EDGES ; } ; virtual int GetPassCellDataPassPointDataPointInterpolation ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PointInterpolation  of  << this -> PointInterpolation ) ; return this -> PointInterpolation ; } ; void SetPointInterpolationToMeshEdges ( ) { this -> SetPointInterpolation ( USE_MESH_EDGES ) ; } void SetPointInterpolationToLoopEdges ( ) { this -> SetPointInterpolation ( USE_LOOP_EDGES ) ; } /@} /@{ *
##  Specify a spatial locator for merging points. By default, an
##  instance of vtkMergePoints is used.
##  void SetLocator ( vtkIncrementalPointLocator * locator ) ; virtual vtkIncrementalPointLocator * GetnameLocator ( ) { vtkDebugWithObjectMacro ( this , <<  returning  Locator  address  << static_cast < vtkIncrementalPointLocator * > ( this -> Locator ) ) ; return this -> Locator ; } ; /@} *
##  Create default locator. Used to create one when none is specified. The
##  locator is used to merge coincident points.
##  void CreateDefaultLocator ( ) ; protected : vtkCookieCutter ( ) ; ~ vtkCookieCutter ( ) override ; int RequestData ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; int RequestUpdateExtent ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; int FillInputPortInformation ( int , vtkInformation * ) override ; bool PassCellData ; bool PassPointData ; int PointInterpolation ; vtkIncrementalPointLocator * Locator ; private : vtkCookieCutter ( const vtkCookieCutter & ) = delete ; void operator = ( const vtkCookieCutter & ) = delete ; } ;
## Error: token expected: ; but got: [identifier]!!!
