## =========================================================================
##
##   Program:   Visualization Toolkit
##   Module:    vtkImageMandelbrotSource.h
##
##   Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
##   All rights reserved.
##   See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
##
##      This software is distributed WITHOUT ANY WARRANTY; without even
##      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##      PURPOSE.  See the above copyright notice for more information.
##
## =========================================================================
## *
##  @class   vtkImageMandelbrotSource
##  @brief   Mandelbrot image.
##
##  vtkImageMandelbrotSource creates an unsigned char image of the Mandelbrot
##  set.  The values in the image are the number of iterations it takes for
##  the magnitude of the value to get over 2.  The equation repeated is
##  z = z^2 + C (z and C are complex).  Initial value of z is zero, and the
##  real value of C is mapped onto the x axis, and the imaginary value of C
##  is mapped onto the Y Axis.  I was thinking of extending this source
##  to generate Julia Sets (initial value of Z varies).  This would be 4
##  possible parameters to vary, but there are no more 4d images :(
##  The third dimension (z axis) is the imaginary value of the initial value.
##

## !!!Ignored construct:  # vtkImageMandelbrotSource_h [NewLine] # vtkImageMandelbrotSource_h [NewLine] # vtkImageAlgorithm.h [NewLine] # vtkImagingSourcesModule.h  For export macro [NewLine] class VTKIMAGINGSOURCES_EXPORT vtkImageMandelbrotSource : public vtkImageAlgorithm { public : static vtkImageMandelbrotSource * New ( ) ; protected : const char * GetClassNameInternal ( ) const override { return thisClass ; } public : typedef vtkImageAlgorithm Superclass ; static vtkTypeBool IsTypeOf ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 1 ; } return vtkImageAlgorithm :: IsTypeOf ( type ) ; } vtkTypeBool IsA ( const char * type ) override { return this -> vtkImageMandelbrotSource :: IsTypeOf ( type ) ; } static vtkImageMandelbrotSource * SafeDownCast ( vtkObjectBase * o ) { if ( o && o -> IsA ( thisClass ) ) { return static_cast < vtkImageMandelbrotSource * > ( o ) ; } return nullptr ; } VTK_NEWINSTANCE vtkImageMandelbrotSource * NewInstance ( ) const { return vtkImageMandelbrotSource :: SafeDownCast ( this -> NewInstanceInternal ( ) ) ; } static vtkIdType GetNumberOfGenerationsFromBaseType ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 0 ; } return 1 + vtkImageAlgorithm :: GetNumberOfGenerationsFromBaseType ( type ) ; } vtkIdType GetNumberOfGenerationsFromBase ( const char * type ) override { return this -> vtkImageMandelbrotSource :: GetNumberOfGenerationsFromBaseType ( type ) ; } public : protected : vtkObjectBase * NewInstanceInternal ( ) const override { return vtkImageMandelbrotSource :: New ( ) ; } public : ; void PrintSelf ( ostream & os , vtkIndent indent ) override ; /@{ *
##  Set/Get the extent of the whole output Volume.
##  void SetWholeExtent ( int extent [ 6 ] ) ; void SetWholeExtent ( int minX , int maxX , int minY , int maxY , int minZ , int maxZ ) ; virtual int * GetWholeExtent ( ) VTK_SIZEHINT ( 6 ) { vtkDebugWithObjectMacro ( this , <<  returning  << WholeExtent  pointer  << this -> WholeExtent ) ; return this -> WholeExtent ; } VTK_WRAPEXCLUDE virtual void GetWholeExtent ( int & _arg1 , int & _arg2 , int & _arg3 , int & _arg4 , int & _arg5 , int & _arg6 ) { _arg1 = this -> WholeExtent [ 0 ] ; _arg2 = this -> WholeExtent [ 1 ] ; _arg3 = this -> WholeExtent [ 2 ] ; _arg4 = this -> WholeExtent [ 3 ] ; _arg5 = this -> WholeExtent [ 4 ] ; _arg6 = this -> WholeExtent [ 5 ] ; vtkDebugWithObjectMacro ( this , <<  returning  << WholeExtent  = ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << , << _arg5 << , << _arg6 << ) ) ; } VTK_WRAPEXCLUDE virtual void GetWholeExtent ( int _arg [ 6 ] ) { this -> GetWholeExtent ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] , _arg [ 4 ] , _arg [ 5 ] ) ; } ; /@} /@{ *
##  This flag determines whether the Size or spacing of
##  a data set remain constant (when extent is changed).
##  By default, size remains constant.
##  virtual void SetConstantSize ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  ConstantSize  to  << _arg ) ; if ( this -> ConstantSize != _arg ) { this -> ConstantSize = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetConstantSize ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ConstantSize  of  << this -> ConstantSize ) ; return this -> ConstantSize ; } ; virtual void ConstantSizeOn ( ) { this -> SetConstantSize ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void ConstantSizeOff ( ) { this -> SetConstantSize ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Set the projection from the 4D space (4 parameters / 2 imaginary numbers)
##  to the axes of the 3D Volume.
##  0=C_Real, 1=C_Imaginary, 2=X_Real, 4=X_Imaginary
##  void SetProjectionAxes ( int x , int y , int z ) ; void SetProjectionAxes ( int a [ 3 ] ) { this -> SetProjectionAxes ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) ; } virtual int * GetProjectionAxes ( ) VTK_SIZEHINT ( 3 ) { vtkDebugWithObjectMacro ( this , <<  returning  << ProjectionAxes  pointer  << this -> ProjectionAxes ) ; return this -> ProjectionAxes ; } VTK_WRAPEXCLUDE virtual void GetProjectionAxes ( int & _arg1 , int & _arg2 , int & _arg3 ) { _arg1 = this -> ProjectionAxes [ 0 ] ; _arg2 = this -> ProjectionAxes [ 1 ] ; _arg3 = this -> ProjectionAxes [ 2 ] ; vtkDebugWithObjectMacro ( this , <<  returning  << ProjectionAxes  = ( << _arg1 << , << _arg2 << , << _arg3 << ) ) ; } VTK_WRAPEXCLUDE virtual void GetProjectionAxes ( int _arg [ 3 ] ) { this -> GetProjectionAxes ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] ) ; } ; /@} /@{ *
##  Imaginary and real value for C (constant in equation)
##  and X (initial value).
##  virtual void SetOriginCX ( double _arg1 , double _arg2 , double _arg3 , double _arg4 ) { vtkDebugWithObjectMacro ( this , <<  setting  << OriginCX  to ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << ) ) ; if ( ( this -> OriginCX [ 0 ] != _arg1 ) || ( this -> OriginCX [ 1 ] != _arg2 ) || ( this -> OriginCX [ 2 ] != _arg3 ) || ( this -> OriginCX [ 3 ] != _arg4 ) ) { this -> OriginCX [ 0 ] = _arg1 ; this -> OriginCX [ 1 ] = _arg2 ; this -> OriginCX [ 2 ] = _arg3 ; this -> OriginCX [ 3 ] = _arg4 ; this -> Modified ( ) ; } } virtual void SetOriginCX ( const double _arg [ 4 ] ) { this -> SetOriginCX ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] ) ; } ;  void SetOriginCX(double cReal, double cImag, double xReal, double xImag); virtual double * GetOriginCX ( ) VTK_SIZEHINT ( 4 ) { vtkDebugWithObjectMacro ( this , <<  returning  << OriginCX  pointer  << this -> OriginCX ) ; return this -> OriginCX ; } VTK_WRAPEXCLUDE virtual void GetOriginCX ( double & _arg1 , double & _arg2 , double & _arg3 , double & _arg4 ) { _arg1 = this -> OriginCX [ 0 ] ; _arg2 = this -> OriginCX [ 1 ] ; _arg3 = this -> OriginCX [ 2 ] ; _arg4 = this -> OriginCX [ 3 ] ; vtkDebugWithObjectMacro ( this , <<  returning  << OriginCX  = ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << ) ) ; } VTK_WRAPEXCLUDE virtual void GetOriginCX ( double _arg [ 4 ] ) { this -> GetOriginCX ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] ) ; } ; /@} /@{ *
##  Imaginary and real value for C (constant in equation)
##  and X (initial value).
##  virtual void SetOriginCXSampleCX ( double _arg1 , double _arg2 , double _arg3 , double _arg4 ) { vtkDebugWithObjectMacro ( this , <<  setting  << SampleCX  to ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << ) ) ; if ( ( this -> SampleCX [ 0 ] != _arg1 ) || ( this -> SampleCX [ 1 ] != _arg2 ) || ( this -> SampleCX [ 2 ] != _arg3 ) || ( this -> SampleCX [ 3 ] != _arg4 ) ) { this -> SampleCX [ 0 ] = _arg1 ; this -> SampleCX [ 1 ] = _arg2 ; this -> SampleCX [ 2 ] = _arg3 ; this -> SampleCX [ 3 ] = _arg4 ; this -> Modified ( ) ; } } virtual void SetOriginCXSampleCX ( const double _arg [ 4 ] ) { this -> SetOriginCXSampleCX ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] ) ; } ;  void SetOriginCX(double cReal, double cImag, double xReal, double xImag); virtual double * GetOriginCXSampleCX ( ) VTK_SIZEHINT ( 4 ) { vtkDebugWithObjectMacro ( this , <<  returning  << SampleCX  pointer  << this -> SampleCX ) ; return this -> SampleCX ; } VTK_WRAPEXCLUDE virtual void GetOriginCXSampleCX ( double & _arg1 , double & _arg2 , double & _arg3 , double & _arg4 ) { _arg1 = this -> SampleCX [ 0 ] ; _arg2 = this -> SampleCX [ 1 ] ; _arg3 = this -> SampleCX [ 2 ] ; _arg4 = this -> SampleCX [ 3 ] ; vtkDebugWithObjectMacro ( this , <<  returning  << SampleCX  = ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << ) ) ; } VTK_WRAPEXCLUDE virtual void GetOriginCXSampleCX ( double _arg [ 4 ] ) { this -> GetOriginCXSampleCX ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] ) ; } ; /@} /@{ *
##  Just a different way of setting the sample.
##  This sets the size of the 4D volume.
##  SampleCX is computed from size and extent.
##  Size is ignored when a dimension i 0 (collapsed).
##  void SetSizeCX ( double cReal , double cImag , double xReal , double xImag ) ; double * GetSizeCX ( ) VTK_SIZEHINT ( 4 ) ; void GetSizeCX ( double s [ 4 ] ) ; /@} /@{ *
##  The maximum number of cycles run to see if the value goes over 2
##  virtual void SetMaximumNumberOfIterations ( unsigned short _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << MaximumNumberOfIterations  to  << _arg ) ; if ( this -> MaximumNumberOfIterations != ( _arg < static_cast < unsigned short > ( 1 ) ? static_cast < unsigned short > ( 1 ) : ( _arg > static_cast < unsigned short > ( 5000 ) ? static_cast < unsigned short > ( 5000 ) : _arg ) ) ) { this -> MaximumNumberOfIterations = ( _arg < static_cast < unsigned short > ( 1 ) ? static_cast < unsigned short > ( 1 ) : ( _arg > static_cast < unsigned short > ( 5000 ) ? static_cast < unsigned short > ( 5000 ) : _arg ) ) ; this -> Modified ( ) ; } } virtual unsigned short GetMaximumNumberOfIterationsMinValue ( ) { return static_cast < unsigned short > ( 1 ) ; } virtual unsigned short GetMaximumNumberOfIterationsMaxValue ( ) { return static_cast < unsigned short > ( 5000 ) ; } ; virtual unsigned short GetConstantSizeMaximumNumberOfIterations ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << MaximumNumberOfIterations  of  << this -> MaximumNumberOfIterations ) ; return this -> MaximumNumberOfIterations ; } ; /@} /@{ *
##  Convenience for Viewer.  Pan 3D volume relative to spacing.
##  Zoom constant factor.
##  void Zoom ( double factor ) ; void Pan ( double x , double y , double z ) ; /@} *
##  Convenience for Viewer.  Copy the OriginCX and the SpacingCX.
##  What about other parameters ???
##  void CopyOriginAndSample ( vtkImageMandelbrotSource * source ) ; /@{ *
##  Set/Get a subsample rate.
##  virtual void SetMaximumNumberOfIterationsSubsampleRate ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << SubsampleRate  to  << _arg ) ; if ( this -> SubsampleRate != ( _arg < 1 ? 1 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ) { this -> SubsampleRate = ( _arg < 1 ? 1 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetMaximumNumberOfIterationsMinValueSubsampleRateMinValue ( ) { return 1 ; } virtual int GetMaximumNumberOfIterationsMaxValueSubsampleRateMaxValue ( ) { return VTK_INT_MAX ; } ; virtual int GetConstantSizeMaximumNumberOfIterationsSubsampleRate ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << SubsampleRate  of  << this -> SubsampleRate ) ; return this -> SubsampleRate ; } ; /@} protected : vtkImageMandelbrotSource ( ) ; ~ vtkImageMandelbrotSource ( ) override ; int ProjectionAxes [ 3 ] ;  WholeExtent in 3 space (after projection). int WholeExtent [ 6 ] ;  Complex constant/initial-value at origin. double OriginCX [ 4 ] ;  Initial complex value at origin. double SampleCX [ 4 ] ; unsigned short MaximumNumberOfIterations ;  A temporary vector that is computed as needed.
##  It is used to return a vector. double SizeCX [ 4 ] ;  A flag for keeping size constant (vs. keeping the spacing). vtkTypeBool ConstantSize ; int SubsampleRate ;  see vtkAlgorithm for details int RequestData ( vtkInformation * request , vtkInformationVector * * inputVector , vtkInformationVector * outputVector ) override ; int RequestInformation ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; double EvaluateSet ( double p [ 4 ] ) ; private : vtkImageMandelbrotSource ( const vtkImageMandelbrotSource & ) = delete ; void operator = ( const vtkImageMandelbrotSource & ) = delete ; } ;
## Error: token expected: ; but got: [identifier]!!!
