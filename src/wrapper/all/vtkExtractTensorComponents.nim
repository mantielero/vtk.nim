## =========================================================================
##
##   Program:   Visualization Toolkit
##   Module:    vtkExtractTensorComponents.h
##
##   Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
##   All rights reserved.
##   See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
##
##      This software is distributed WITHOUT ANY WARRANTY; without even
##      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##      PURPOSE.  See the above copyright notice for more information.
##
## =========================================================================
## *
##  @class   vtkExtractTensorComponents
##  @brief   extract parts of tensor and create a scalar, vector, normal, or texture coordinates.
##
##  vtkExtractTensorComponents is a filter that extracts components of a
##  tensor to create a scalar, vector, normal, and/or texture coords. For
##  example, if the tensor contains components of stress, then you could
##  extract the normal stress in the x-direction as a scalar (i.e., tensor
##  component (0,0)).
##
##  To use this filter, you must set some boolean flags to control
##  which data is extracted from the tensors, and whether you want to
##  pass the tensor data through to the output. Also, you must specify
##  the tensor component(s) for each type of data you want to
##  extract. The tensor component(s) is(are) specified using matrix notation
##  into a 3x3 matrix. That is, use the (row,column) address to specify
##  a particular tensor component; and if the data you are extracting
##  requires more than one component, use a list of addresses. (Note
##  that the addresses are 0-offset -> (0,0) specifies the upper left
##  corner of the tensor.)
##
##  There are two optional methods to extract scalar data. You can
##  extract the determinant of the tensor, or you can extract the
##  effective stress of the tensor. These require that the ivar
##  ExtractScalars is on, and the appropriate scalar extraction mode is
##  set.
##
##  @warning
##  This class has been threaded with vtkSMPTools. Using TBB or other
##  non-sequential type (set in the CMake variable
##  VTK_SMP_IMPLEMENTATION_TYPE) may improve performance significantly.
##
##  @sa
##  vtkTensorWidget vtkTensorGlyph vtkPointSmoothingFilter
##  vtkHyperStreamline
##

## !!!Ignored construct:  # vtkExtractTensorComponents_h [NewLine] # vtkExtractTensorComponents_h [NewLine] # vtkDataSetAlgorithm.h [NewLine] # vtkFiltersExtractionModule.h  For export macro [NewLine] # VTK_EXTRACT_COMPONENT 0 [NewLine] # VTK_EXTRACT_EFFECTIVE_STRESS 1 [NewLine] # VTK_EXTRACT_DETERMINANT 2 [NewLine] # VTK_EXTRACT_NONNEGATIVE_DETERMINANT 3 [NewLine] # VTK_EXTRACT_TRACE 4 [NewLine] class VTKFILTERSEXTRACTION_EXPORT vtkExtractTensorComponents : public vtkDataSetAlgorithm { public : /@{ *
##  Standard methods for obtaining type information, and printing.
##  protected : const char * GetClassNameInternal ( ) const override { return thisClass ; } public : typedef vtkDataSetAlgorithm Superclass ; static vtkTypeBool IsTypeOf ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 1 ; } return vtkDataSetAlgorithm :: IsTypeOf ( type ) ; } vtkTypeBool IsA ( const char * type ) override { return this -> vtkExtractTensorComponents :: IsTypeOf ( type ) ; } static vtkExtractTensorComponents * SafeDownCast ( vtkObjectBase * o ) { if ( o && o -> IsA ( thisClass ) ) { return static_cast < vtkExtractTensorComponents * > ( o ) ; } return nullptr ; } VTK_NEWINSTANCE vtkExtractTensorComponents * NewInstance ( ) const { return vtkExtractTensorComponents :: SafeDownCast ( this -> NewInstanceInternal ( ) ) ; } static vtkIdType GetNumberOfGenerationsFromBaseType ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 0 ; } return 1 + vtkDataSetAlgorithm :: GetNumberOfGenerationsFromBaseType ( type ) ; } vtkIdType GetNumberOfGenerationsFromBase ( const char * type ) override { return this -> vtkExtractTensorComponents :: GetNumberOfGenerationsFromBaseType ( type ) ; } public : protected : vtkObjectBase * NewInstanceInternal ( ) const override { return vtkExtractTensorComponents :: New ( ) ; } public : ; void PrintSelf ( ostream & os , vtkIndent indent ) override ; /@} *
##  Construct object to extract nothing and to not pass tensor data
##  through the pipeline.
##  static vtkExtractTensorComponents * New ( ) ; /@{ *
##  Boolean controls whether tensor data is passed through to the output.
##  virtual void SetPassTensorsToOutput ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  PassTensorsToOutput  to  << _arg ) ; if ( this -> PassTensorsToOutput != _arg ) { this -> PassTensorsToOutput = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPassTensorsToOutput ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << PassTensorsToOutput  of  << this -> PassTensorsToOutput ) ; return this -> PassTensorsToOutput ; } ; virtual void PassTensorsToOutputOn ( ) { this -> SetPassTensorsToOutput ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void PassTensorsToOutputOff ( ) { this -> SetPassTensorsToOutput ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Boolean controls whether scalar data is extracted from the tensors.
##  virtual void SetPassTensorsToOutputExtractScalars ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  ExtractScalars  to  << _arg ) ; if ( this -> ExtractScalars != _arg ) { this -> ExtractScalars = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPassTensorsToOutputExtractScalars ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ExtractScalars  of  << this -> ExtractScalars ) ; return this -> ExtractScalars ; } ; virtual void ExtractScalarsOn ( ) { this -> SetPassTensorsToOutputExtractScalars ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void ExtractScalarsOff ( ) { this -> SetPassTensorsToOutputExtractScalars ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Specify the (row,column) tensor component to extract as a scalar.
##  virtual void SetScalarComponents ( int _arg1 , int _arg2 ) { vtkDebugWithObjectMacro ( this , <<  setting  << ScalarComponents  to ( << _arg1 << , << _arg2 << ) ) ; if ( ( this -> ScalarComponents [ 0 ] != _arg1 ) || ( this -> ScalarComponents [ 1 ] != _arg2 ) ) { this -> ScalarComponents [ 0 ] = _arg1 ; this -> ScalarComponents [ 1 ] = _arg2 ; this -> Modified ( ) ; } } void SetScalarComponents ( const int _arg [ 2 ] ) { this -> SetScalarComponents ( _arg [ 0 ] , _arg [ 1 ] ) ; } ; virtual int * GetScalarComponents ( ) VTK_SIZEHINT ( 2 ) { vtkDebugWithObjectMacro ( this , <<  returning  << ScalarComponents  pointer  << this -> ScalarComponents ) ; return this -> ScalarComponents ; } VTK_WRAPEXCLUDE virtual void GetScalarComponents ( int data [ 2 ] ) { for ( int i = 0 ; i < 2 ; i ++ ) { data [ i ] = this -> ScalarComponents [ i ] ; } } ; /@} /@{ *
##  Specify how to extract the scalar. You can extract it as one of the
##  components of the tensor, as effective stress, as the determinant of the
##  tensor, a non-negative determinant, or the trace of the tensor
##  matrix. If you extract a component make sure that you set the
##  ScalarComponents ivar.
##  virtual void SetPassTensorsToOutputExtractScalarsScalarMode ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  ScalarMode  to  << _arg ) ; if ( this -> ScalarMode != _arg ) { this -> ScalarMode = _arg ; this -> Modified ( ) ; } } ; virtual int GetPassTensorsToOutputExtractScalarsScalarMode ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ScalarMode  of  << this -> ScalarMode ) ; return this -> ScalarMode ; } ; void SetScalarModeToComponent ( ) { this -> SetScalarMode ( VTK_EXTRACT_COMPONENT ) ; } void SetScalarModeToEffectiveStress ( ) { this -> SetScalarMode ( VTK_EXTRACT_EFFECTIVE_STRESS ) ; } void SetScalarModeToDeterminant ( ) { this -> SetScalarMode ( VTK_EXTRACT_DETERMINANT ) ; } void SetScalarModeToNonNegativeDeterminant ( ) { this -> SetScalarMode ( VTK_EXTRACT_NONNEGATIVE_DETERMINANT ) ; } void SetScalarModeToTrace ( ) { this -> SetScalarMode ( VTK_EXTRACT_TRACE ) ; } void ScalarIsComponent ( ) { this -> SetScalarMode ( VTK_EXTRACT_COMPONENT ) ; } void ScalarIsEffectiveStress ( ) { this -> SetScalarMode ( VTK_EXTRACT_EFFECTIVE_STRESS ) ; } void ScalarIsDeterminant ( ) { this -> SetScalarMode ( VTK_EXTRACT_DETERMINANT ) ; } void ScalarIsNonNegativeDeterminant ( ) { this -> SetScalarMode ( VTK_EXTRACT_NONNEGATIVE_DETERMINANT ) ; } void ScalarIsTrace ( ) { this -> SetScalarMode ( VTK_EXTRACT_TRACE ) ; } /@} /@{ *
##  Boolean controls whether vector data is extracted from tensor.
##  virtual void SetPassTensorsToOutputExtractScalarsScalarModeExtractVectors ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  ExtractVectors  to  << _arg ) ; if ( this -> ExtractVectors != _arg ) { this -> ExtractVectors = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPassTensorsToOutputExtractScalarsScalarModeExtractVectors ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ExtractVectors  of  << this -> ExtractVectors ) ; return this -> ExtractVectors ; } ; virtual void ExtractVectorsOn ( ) { this -> SetPassTensorsToOutputExtractScalarsExtractVectors ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void ExtractVectorsOff ( ) { this -> SetPassTensorsToOutputExtractScalarsExtractVectors ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Specify the ((row,column)0,(row,column)1,(row,column)2) tensor
##  components to extract as a vector.
##  virtual void SetVectorComponents ( int _arg1 , int _arg2 , int _arg3 , int _arg4 , int _arg5 , int _arg6 ) { vtkDebugWithObjectMacro ( this , <<  setting  << VectorComponents  to ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << , << _arg5 << , << _arg6 << ) ) ; if ( ( this -> VectorComponents [ 0 ] != _arg1 ) || ( this -> VectorComponents [ 1 ] != _arg2 ) || ( this -> VectorComponents [ 2 ] != _arg3 ) || ( this -> VectorComponents [ 3 ] != _arg4 ) || ( this -> VectorComponents [ 4 ] != _arg5 ) || ( this -> VectorComponents [ 5 ] != _arg6 ) ) { this -> VectorComponents [ 0 ] = _arg1 ; this -> VectorComponents [ 1 ] = _arg2 ; this -> VectorComponents [ 2 ] = _arg3 ; this -> VectorComponents [ 3 ] = _arg4 ; this -> VectorComponents [ 4 ] = _arg5 ; this -> VectorComponents [ 5 ] = _arg6 ; this -> Modified ( ) ; } } virtual void SetVectorComponents ( const int _arg [ 6 ] ) { this -> SetVectorComponents ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] , _arg [ 4 ] , _arg [ 5 ] ) ; } ; virtual int * GetScalarComponentsVectorComponents ( ) VTK_SIZEHINT ( 6 ) { vtkDebugWithObjectMacro ( this , <<  returning  << VectorComponents  pointer  << this -> VectorComponents ) ; return this -> VectorComponents ; } VTK_WRAPEXCLUDE virtual void GetScalarComponentsVectorComponents ( int data [ 6 ] ) { for ( int i = 0 ; i < 6 ; i ++ ) { data [ i ] = this -> VectorComponents [ i ] ; } } ; /@} /@{ *
##  Boolean controls whether normal data is extracted from tensor.
##  virtual void SetPassTensorsToOutputExtractScalarsScalarModeExtractVectorsExtractNormals ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  ExtractNormals  to  << _arg ) ; if ( this -> ExtractNormals != _arg ) { this -> ExtractNormals = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPassTensorsToOutputExtractScalarsScalarModeExtractVectorsExtractNormals ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ExtractNormals  of  << this -> ExtractNormals ) ; return this -> ExtractNormals ; } ; virtual void ExtractNormalsOn ( ) { this -> SetPassTensorsToOutputExtractScalarsExtractVectorsExtractNormals ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void ExtractNormalsOff ( ) { this -> SetPassTensorsToOutputExtractScalarsExtractVectorsExtractNormals ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Boolean controls whether normal vector is converted to unit normal
##  after extraction.
##  virtual void SetPassTensorsToOutputExtractScalarsScalarModeExtractVectorsExtractNormalsNormalizeNormals ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  NormalizeNormals  to  << _arg ) ; if ( this -> NormalizeNormals != _arg ) { this -> NormalizeNormals = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPassTensorsToOutputExtractScalarsScalarModeExtractVectorsExtractNormalsNormalizeNormals ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << NormalizeNormals  of  << this -> NormalizeNormals ) ; return this -> NormalizeNormals ; } ; virtual void NormalizeNormalsOn ( ) { this -> SetPassTensorsToOutputExtractScalarsExtractVectorsExtractNormalsNormalizeNormals ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void NormalizeNormalsOff ( ) { this -> SetPassTensorsToOutputExtractScalarsExtractVectorsExtractNormalsNormalizeNormals ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Specify the ((row,column)0,(row,column)1,(row,column)2) tensor
##  components to extract as a vector.
##  virtual void SetVectorComponentsNormalComponents ( int _arg1 , int _arg2 , int _arg3 , int _arg4 , int _arg5 , int _arg6 ) { vtkDebugWithObjectMacro ( this , <<  setting  << NormalComponents  to ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << , << _arg5 << , << _arg6 << ) ) ; if ( ( this -> NormalComponents [ 0 ] != _arg1 ) || ( this -> NormalComponents [ 1 ] != _arg2 ) || ( this -> NormalComponents [ 2 ] != _arg3 ) || ( this -> NormalComponents [ 3 ] != _arg4 ) || ( this -> NormalComponents [ 4 ] != _arg5 ) || ( this -> NormalComponents [ 5 ] != _arg6 ) ) { this -> NormalComponents [ 0 ] = _arg1 ; this -> NormalComponents [ 1 ] = _arg2 ; this -> NormalComponents [ 2 ] = _arg3 ; this -> NormalComponents [ 3 ] = _arg4 ; this -> NormalComponents [ 4 ] = _arg5 ; this -> NormalComponents [ 5 ] = _arg6 ; this -> Modified ( ) ; } } virtual void SetVectorComponentsNormalComponents ( const int _arg [ 6 ] ) { this -> SetVectorComponentsNormalComponents ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] , _arg [ 4 ] , _arg [ 5 ] ) ; } ; virtual int * GetScalarComponentsVectorComponentsNormalComponents ( ) VTK_SIZEHINT ( 6 ) { vtkDebugWithObjectMacro ( this , <<  returning  << NormalComponents  pointer  << this -> NormalComponents ) ; return this -> NormalComponents ; } VTK_WRAPEXCLUDE virtual void GetScalarComponentsVectorComponentsNormalComponents ( int data [ 6 ] ) { for ( int i = 0 ; i < 6 ; i ++ ) { data [ i ] = this -> NormalComponents [ i ] ; } } ; /@} /@{ *
##  Boolean controls whether texture coordinates are extracted from tensor.
##  virtual void SetPassTensorsToOutputExtractScalarsScalarModeExtractVectorsExtractNormalsNormalizeNormalsExtractTCoords ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  ExtractTCoords  to  << _arg ) ; if ( this -> ExtractTCoords != _arg ) { this -> ExtractTCoords = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetPassTensorsToOutputExtractScalarsScalarModeExtractVectorsExtractNormalsNormalizeNormalsExtractTCoords ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ExtractTCoords  of  << this -> ExtractTCoords ) ; return this -> ExtractTCoords ; } ; virtual void ExtractTCoordsOn ( ) { this -> SetPassTensorsToOutputExtractScalarsExtractVectorsExtractNormalsNormalizeNormalsExtractTCoords ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void ExtractTCoordsOff ( ) { this -> SetPassTensorsToOutputExtractScalarsExtractVectorsExtractNormalsNormalizeNormalsExtractTCoords ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Set the dimension of the texture coordinates to extract.
##  virtual void SetNumberOfTCoords ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << NumberOfTCoords  to  << _arg ) ; if ( this -> NumberOfTCoords != ( _arg < 1 ? 1 : ( _arg > 3 ? 3 : _arg ) ) ) { this -> NumberOfTCoords = ( _arg < 1 ? 1 : ( _arg > 3 ? 3 : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetNumberOfTCoordsMinValue ( ) { return 1 ; } virtual int GetNumberOfTCoordsMaxValue ( ) { return 3 ; } ; virtual int GetPassTensorsToOutputExtractScalarsScalarModeExtractVectorsExtractNormalsNormalizeNormalsExtractTCoordsNumberOfTCoords ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << NumberOfTCoords  of  << this -> NumberOfTCoords ) ; return this -> NumberOfTCoords ; } ; /@} /@{ *
##  Specify the ((row,column)0,(row,column)1,(row,column)2) tensor
##  components to extract as a vector. Up to NumberOfTCoords
##  components are extracted.
##  virtual void SetVectorComponentsNormalComponentsTCoordComponents ( int _arg1 , int _arg2 , int _arg3 , int _arg4 , int _arg5 , int _arg6 ) { vtkDebugWithObjectMacro ( this , <<  setting  << TCoordComponents  to ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << , << _arg5 << , << _arg6 << ) ) ; if ( ( this -> TCoordComponents [ 0 ] != _arg1 ) || ( this -> TCoordComponents [ 1 ] != _arg2 ) || ( this -> TCoordComponents [ 2 ] != _arg3 ) || ( this -> TCoordComponents [ 3 ] != _arg4 ) || ( this -> TCoordComponents [ 4 ] != _arg5 ) || ( this -> TCoordComponents [ 5 ] != _arg6 ) ) { this -> TCoordComponents [ 0 ] = _arg1 ; this -> TCoordComponents [ 1 ] = _arg2 ; this -> TCoordComponents [ 2 ] = _arg3 ; this -> TCoordComponents [ 3 ] = _arg4 ; this -> TCoordComponents [ 4 ] = _arg5 ; this -> TCoordComponents [ 5 ] = _arg6 ; this -> Modified ( ) ; } } virtual void SetVectorComponentsNormalComponentsTCoordComponents ( const int _arg [ 6 ] ) { this -> SetVectorComponentsNormalComponentsTCoordComponents ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] , _arg [ 4 ] , _arg [ 5 ] ) ; } ; virtual int * GetScalarComponentsVectorComponentsNormalComponentsTCoordComponents ( ) VTK_SIZEHINT ( 6 ) { vtkDebugWithObjectMacro ( this , <<  returning  << TCoordComponents  pointer  << this -> TCoordComponents ) ; return this -> TCoordComponents ; } VTK_WRAPEXCLUDE virtual void GetScalarComponentsVectorComponentsNormalComponentsTCoordComponents ( int data [ 6 ] ) { for ( int i = 0 ; i < 6 ; i ++ ) { data [ i ] = this -> TCoordComponents [ i ] ; } } ; /@} /@{ *
##  Set/get the desired precision for the output types. See the
##  documentation for the vtkAlgorithm::DesiredOutputPrecision enum for an
##  explanation of the available precision settings. Note that any data that
##  is simply passed through the filter to its output retains its input
##  type, only newly created data added to the output is affected by this
##  flag. By default the output type is the same as the input tensor type.
##  virtual void SetPassTensorsToOutputExtractScalarsScalarModeExtractVectorsExtractNormalsNormalizeNormalsExtractTCoordsOutputPrecision ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  OutputPrecision  to  << _arg ) ; if ( this -> OutputPrecision != _arg ) { this -> OutputPrecision = _arg ; this -> Modified ( ) ; } } ; virtual int GetPassTensorsToOutputExtractScalarsScalarModeExtractVectorsExtractNormalsNormalizeNormalsExtractTCoordsNumberOfTCoordsOutputPrecision ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << OutputPrecision  of  << this -> OutputPrecision ) ; return this -> OutputPrecision ; } ; /@} protected : vtkExtractTensorComponents ( ) ; ~ vtkExtractTensorComponents ( ) override = default ; int RequestData ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; vtkTypeBool PassTensorsToOutput ; vtkTypeBool ExtractScalars ; vtkTypeBool ExtractVectors ; vtkTypeBool ExtractNormals ; vtkTypeBool ExtractTCoords ; int ScalarMode ; int ScalarComponents [ 2 ] ; int VectorComponents [ 6 ] ; vtkTypeBool NormalizeNormals ; int NormalComponents [ 6 ] ; int NumberOfTCoords ; int TCoordComponents [ 6 ] ; int OutputPrecision ; private : vtkExtractTensorComponents ( const vtkExtractTensorComponents & ) = delete ; void operator = ( const vtkExtractTensorComponents & ) = delete ; } ;
## Error: token expected: ; but got: [identifier]!!!
