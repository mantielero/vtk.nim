## =========================================================================
##
##   Program:   ParaView
##   Module:    vtkTemporalFractal.h
##
##   Copyright (c) Kitware, Inc.
##   All rights reserved.
##   See Copyright.txt or http://www.paraview.org/HTML/Copyright.html for details.
##
##      This software is distributed WITHOUT ANY WARRANTY; without even
##      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##      PURPOSE.  See the above copyright notice for more information.
##
## =========================================================================
## *
##  @class   vtkTemporalFractal
##  @brief   A source to test AMR data object.
##
##  vtkTemporalFractal is a collection of uniform grids.  All have the same
##  dimensions. Each block has a different origin and spacing.  It uses
##  mandelbrot to create cell data. The fractal array is scaled to look like a
##  volume fraction.
##
##  I may also add block id and level as extra cell arrays.
##  This source produces a vtkHierarchicalBoxDataSet when
##  GenerateRectilinearGrids is off, otherwise produces a vtkMultiBlockDataSet.
##

## !!!Ignored construct:  # vtkTemporalFractal_h [NewLine] # vtkTemporalFractal_h [NewLine] # vtkAlgorithm.h [NewLine] # vtkFiltersHybridModule.h  For export macro # vtkSmartPointer.h for ivars [NewLine] class vtkCompositeDataSet ;
## Error: token expected: ; but got: [identifier]!!!

discard "forward decl of vtkDataSet"
discard "forward decl of vtkHierarchicalBoxDataSet"
discard "forward decl of vtkIntArray"
discard "forward decl of vtkRectilinearGrid"
discard "forward decl of vtkUniformGrid"
discard "forward decl of TemporalFractalOutputUtil"
## !!!Ignored construct:  class VTKFILTERSHYBRID_EXPORT vtkTemporalFractal : public vtkAlgorithm { public : /@{ *
##  Standard methods for instantiation, type information, and printing.
##  static vtkTemporalFractal * New ( ) ; protected : const char * GetClassNameInternal ( ) const override { return thisClass ; } public : typedef vtkAlgorithm Superclass ; static vtkTypeBool IsTypeOf ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 1 ; } return vtkAlgorithm :: IsTypeOf ( type ) ; } vtkTypeBool IsA ( const char * type ) override { return this -> vtkTemporalFractal :: IsTypeOf ( type ) ; } static vtkTemporalFractal * SafeDownCast ( vtkObjectBase * o ) { if ( o && o -> IsA ( thisClass ) ) { return static_cast < vtkTemporalFractal * > ( o ) ; } return nullptr ; } VTK_NEWINSTANCE vtkTemporalFractal * NewInstance ( ) const { return vtkTemporalFractal :: SafeDownCast ( this -> NewInstanceInternal ( ) ) ; } static vtkIdType GetNumberOfGenerationsFromBaseType ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 0 ; } return 1 + vtkAlgorithm :: GetNumberOfGenerationsFromBaseType ( type ) ; } vtkIdType GetNumberOfGenerationsFromBase ( const char * type ) override { return this -> vtkTemporalFractal :: GetNumberOfGenerationsFromBaseType ( type ) ; } public : protected : vtkObjectBase * NewInstanceInternal ( ) const override { return vtkTemporalFractal :: New ( ) ; } public : ; void PrintSelf ( ostream & os , vtkIndent indent ) override ; /@} /@{ *
##  Essentially the iso surface value.  The fractal array is scaled to map
##  this value to 0.5 for use as a volume fraction.
##  virtual void SetFractalValue ( float _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  FractalValue  to  << _arg ) ; if ( this -> FractalValue != _arg ) { this -> FractalValue = _arg ; this -> Modified ( ) ; } } ; virtual float GetFractalValue ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << FractalValue  of  << this -> FractalValue ) ; return this -> FractalValue ; } ; /@} /@{ *
##  Any blocks touching a predefined line will be subdivided to this level.
##  Other blocks are subdivided so that neighboring blocks only differ
##  by one level.
##  virtual void SetFractalValueMaximumLevel ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  MaximumLevel  to  << _arg ) ; if ( this -> MaximumLevel != _arg ) { this -> MaximumLevel = _arg ; this -> Modified ( ) ; } } ; virtual int GetFractalValueMaximumLevel ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << MaximumLevel  of  << this -> MaximumLevel ) ; return this -> MaximumLevel ; } ; /@} /@{ *
##  XYZ dimensions of cells.
##  virtual void SetFractalValueMaximumLevelDimensions ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  Dimensions  to  << _arg ) ; if ( this -> Dimensions != _arg ) { this -> Dimensions = _arg ; this -> Modified ( ) ; } } ; virtual int GetFractalValueMaximumLevelDimensions ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << Dimensions  of  << this -> Dimensions ) ; return this -> Dimensions ; } ; /@} /@{ *
##  For testing ghost levels.
##  virtual void SetFractalValueMaximumLevelDimensionsGhostLevels ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  GhostLevels  to  << _arg ) ; if ( this -> GhostLevels != _arg ) { this -> GhostLevels = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetFractalValueMaximumLevelDimensionsGhostLevels ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << GhostLevels  of  << this -> GhostLevels ) ; return this -> GhostLevels ; } ; virtual void GhostLevelsOn ( ) { this -> SetGhostLevels ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void GhostLevelsOff ( ) { this -> SetGhostLevels ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Generate either rectilinear grids either uniform grids.
##  Default is false.
##  virtual void SetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGrids ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  GenerateRectilinearGrids  to  << _arg ) ; if ( this -> GenerateRectilinearGrids != _arg ) { this -> GenerateRectilinearGrids = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGrids ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << GenerateRectilinearGrids  of  << this -> GenerateRectilinearGrids ) ; return this -> GenerateRectilinearGrids ; } ; virtual void GenerateRectilinearGridsOn ( ) { this -> SetGhostLevelsGenerateRectilinearGrids ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void GenerateRectilinearGridsOff ( ) { this -> SetGhostLevelsGenerateRectilinearGrids ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Limit this source to discrete integer time steps
##  Default is off (continuous)
##  virtual void SetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGridsDiscreteTimeSteps ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  DiscreteTimeSteps  to  << _arg ) ; if ( this -> DiscreteTimeSteps != _arg ) { this -> DiscreteTimeSteps = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGridsDiscreteTimeSteps ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << DiscreteTimeSteps  of  << this -> DiscreteTimeSteps ) ; return this -> DiscreteTimeSteps ; } ; virtual void DiscreteTimeStepsOn ( ) { this -> SetGhostLevelsGenerateRectilinearGridsDiscreteTimeSteps ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void DiscreteTimeStepsOff ( ) { this -> SetGhostLevelsGenerateRectilinearGridsDiscreteTimeSteps ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Make a 2D data set to test.
##  virtual void SetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensional ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  TwoDimensional  to  << _arg ) ; if ( this -> TwoDimensional != _arg ) { this -> TwoDimensional = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensional ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << TwoDimensional  of  << this -> TwoDimensional ) ; return this -> TwoDimensional ; } ; virtual void TwoDimensionalOn ( ) { this -> SetGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensional ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void TwoDimensionalOff ( ) { this -> SetGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensional ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Test the case when the blocks do not have the same sizes.
##  Adds 2 to the x extent of the far x blocks (level 1).
##  virtual void SetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensionalAsymmetric ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  Asymmetric  to  << _arg ) ; if ( this -> Asymmetric != _arg ) { this -> Asymmetric = _arg ; this -> Modified ( ) ; } } ; virtual int GetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensionalAsymmetric ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << Asymmetric  of  << this -> Asymmetric ) ; return this -> Asymmetric ; } ; /@} /@{ *
##  Make the division adaptive or not, defaults to Adaptive
##  virtual void SetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensionalAsymmetricAdaptiveSubdivision ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  AdaptiveSubdivision  to  << _arg ) ; if ( this -> AdaptiveSubdivision != _arg ) { this -> AdaptiveSubdivision = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetFractalValueMaximumLevelDimensionsGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensionalAsymmetricAdaptiveSubdivision ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << AdaptiveSubdivision  of  << this -> AdaptiveSubdivision ) ; return this -> AdaptiveSubdivision ; } ; virtual void AdaptiveSubdivisionOn ( ) { this -> SetGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensionalAdaptiveSubdivision ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void AdaptiveSubdivisionOff ( ) { this -> SetGhostLevelsGenerateRectilinearGridsDiscreteTimeStepsTwoDimensionalAdaptiveSubdivision ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} protected : vtkTemporalFractal ( ) ; ~ vtkTemporalFractal ( ) override ; int FillOutputPortInformation ( int vtkNotUsed ( port ) , vtkInformation * info ) override ; int StartBlock ; int EndBlock ; int BlockCount ; *
##  see vtkAlgorithm for details
##  vtkTypeBool ProcessRequest ( vtkInformation * request , vtkInformationVector * * inputVector , vtkInformationVector * outputVector ) override ; *
##  This is called by the superclass.
##  This is the method you should override.
##  virtual int RequestDataObject ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) ; *
##  This is called by the superclass.
##  This is the method you should override.
##  virtual int RequestInformation ( vtkInformation * request , vtkInformationVector * * inputVector , vtkInformationVector * outputVector ) ; /@{ *
##  This is called by the superclass.
##  This is the method you should override.
##  virtual int RequestData ( vtkInformation * request , vtkInformationVector * * inputVector , vtkInformationVector * outputVector ) ; virtual int RequestOneTimeStep ( vtkCompositeDataSet * output , vtkInformation * request , vtkInformationVector * * inputVector , vtkInformationVector * outputVector ) ; /@} void Traverse ( int & blockId , int level , vtkDataObject * output , int x0 , int x1 , int y0 , int y1 , int z0 , int z1 , int onFace [ 6 ] ) ; int LineTest2 ( float x0 , float y0 , float z0 , float x1 , float y1 , float z1 , double bds [ 6 ] ) ; int LineTest ( float x0 , float y0 , float z0 , float x1 , float y1 , float z1 , double bds [ 6 ] , int level , int target ) ; void SetBlockInfo ( vtkUniformGrid * grid , int level , int * ext , int onFace [ 6 ] ) ; void SetRBlockInfo ( vtkRectilinearGrid * grid , int level , int * ext , int onFace [ 6 ] ) ; void AddVectorArray ( vtkHierarchicalBoxDataSet * output ) ; void AddTestArray ( vtkHierarchicalBoxDataSet * output ) ; void AddFractalArray ( vtkCompositeDataSet * output ) ; void AddBlockIdArray ( vtkHierarchicalBoxDataSet * output ) ; void AddDepthArray ( vtkHierarchicalBoxDataSet * output ) ; void AddGhostLevelArray ( vtkDataSet * grid , int dim [ 3 ] , int onFace [ 6 ] ) ; int MandelbrotTest ( double x , double y ) ; int TwoDTest ( double bds [ 6 ] , int level , int target ) ; void CellExtentToBounds ( int level , int ext [ 6 ] , double bds [ 6 ] ) ; void ExecuteRectilinearMandelbrot ( vtkRectilinearGrid * grid , double * ptr ) ; double EvaluateSet ( double p [ 4 ] ) ; void GetContinuousIncrements ( int extent [ 6 ] , vtkIdType & incX , vtkIdType & incY , vtkIdType & incZ ) ;  Dimensions:
##  Specify blocks relative to this top level block.
##  For now this has to be set before the blocks are defined. virtual void SetTopLevelSpacing ( double _arg1 , double _arg2 , double _arg3 ) { vtkDebugWithObjectMacro ( this , <<  setting  << TopLevelSpacing  to ( << _arg1 << , << _arg2 << , << _arg3 << ) ) ; if ( ( this -> TopLevelSpacing [ 0 ] != _arg1 ) || ( this -> TopLevelSpacing [ 1 ] != _arg2 ) || ( this -> TopLevelSpacing [ 2 ] != _arg3 ) ) { this -> TopLevelSpacing [ 0 ] = _arg1 ; this -> TopLevelSpacing [ 1 ] = _arg2 ; this -> TopLevelSpacing [ 2 ] = _arg3 ; this -> Modified ( ) ; } } virtual void SetTopLevelSpacing ( const double _arg [ 3 ] ) { this -> SetTopLevelSpacing ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] ) ; } ; virtual double * GetTopLevelSpacing ( ) VTK_SIZEHINT ( 3 ) { vtkDebugWithObjectMacro ( this , <<  returning  << TopLevelSpacing  pointer  << this -> TopLevelSpacing ) ; return this -> TopLevelSpacing ; } VTK_WRAPEXCLUDE virtual void GetTopLevelSpacing ( double & _arg1 , double & _arg2 , double & _arg3 ) { _arg1 = this -> TopLevelSpacing [ 0 ] ; _arg2 = this -> TopLevelSpacing [ 1 ] ; _arg3 = this -> TopLevelSpacing [ 2 ] ; vtkDebugWithObjectMacro ( this , <<  returning  << TopLevelSpacing  = ( << _arg1 << , << _arg2 << , << _arg3 << ) ) ; } VTK_WRAPEXCLUDE virtual void GetTopLevelSpacing ( double _arg [ 3 ] ) { this -> GetTopLevelSpacing ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] ) ; } ; virtual void SetTopLevelSpacingTopLevelOrigin ( double _arg1 , double _arg2 , double _arg3 ) { vtkDebugWithObjectMacro ( this , <<  setting  << TopLevelOrigin  to ( << _arg1 << , << _arg2 << , << _arg3 << ) ) ; if ( ( this -> TopLevelOrigin [ 0 ] != _arg1 ) || ( this -> TopLevelOrigin [ 1 ] != _arg2 ) || ( this -> TopLevelOrigin [ 2 ] != _arg3 ) ) { this -> TopLevelOrigin [ 0 ] = _arg1 ; this -> TopLevelOrigin [ 1 ] = _arg2 ; this -> TopLevelOrigin [ 2 ] = _arg3 ; this -> Modified ( ) ; } } virtual void SetTopLevelSpacingTopLevelOrigin ( const double _arg [ 3 ] ) { this -> SetTopLevelSpacingTopLevelOrigin ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] ) ; } ; virtual double * GetTopLevelSpacingTopLevelOrigin ( ) VTK_SIZEHINT ( 3 ) { vtkDebugWithObjectMacro ( this , <<  returning  << TopLevelOrigin  pointer  << this -> TopLevelOrigin ) ; return this -> TopLevelOrigin ; } VTK_WRAPEXCLUDE virtual void GetTopLevelSpacingTopLevelOrigin ( double & _arg1 , double & _arg2 , double & _arg3 ) { _arg1 = this -> TopLevelOrigin [ 0 ] ; _arg2 = this -> TopLevelOrigin [ 1 ] ; _arg3 = this -> TopLevelOrigin [ 2 ] ; vtkDebugWithObjectMacro ( this , <<  returning  << TopLevelOrigin  = ( << _arg1 << , << _arg2 << , << _arg3 << ) ) ; } VTK_WRAPEXCLUDE virtual void GetTopLevelSpacingTopLevelOrigin ( double _arg [ 3 ] ) { this -> GetTopLevelSpacingTopLevelOrigin ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] ) ; } ; void InternalImageDataCopy ( vtkTemporalFractal * src ) ; int Asymmetric ; int MaximumLevel ; int Dimensions ; float FractalValue ; vtkTypeBool GhostLevels ; vtkIntArray * Levels ; vtkTypeBool TwoDimensional ; vtkTypeBool DiscreteTimeSteps ;  New method of specifying blocks. double TopLevelSpacing [ 3 ] ; double TopLevelOrigin [ 3 ] ; vtkTypeBool GenerateRectilinearGrids ; double CurrentTime ; vtkTypeBool AdaptiveSubdivision ; vtkSmartPointer < TemporalFractalOutputUtil > OutputUtil ; private : vtkTemporalFractal ( const vtkTemporalFractal & ) = delete ; void operator = ( const vtkTemporalFractal & ) = delete ; } ;
## Error: token expected: ; but got: [identifier]!!!
