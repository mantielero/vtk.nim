## =========================================================================
##
##   Program:   Visualization Toolkit
##   Module:    vtkPTSReader.h
##
##   Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
##   All rights reserved.
##   See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
##
##      This software is distributed WITHOUT ANY WARRANTY; without even
##      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##      PURPOSE.  See the above copyright notice for more information.
##
## =========================================================================
## *
##  @class   vtkPTSReader
##  @brief   Read ASCII PTS Files.
##
##  vtkPTSReader reads either a text file of
##   points. The first line is the number of points. Point information is
##   either x y z intensity or x y z intensity r g b
##

## !!!Ignored construct:  # vtkPTSReader_h [NewLine] # vtkPTSReader_h [NewLine] # vtkBoundingBox.h  For Bounding Box Data Member # vtkIOGeometryModule.h  For export macro # vtkPolyDataAlgorithm.h [NewLine] class VTKIOGEOMETRY_EXPORT vtkPTSReader : public vtkPolyDataAlgorithm { public : static vtkPTSReader * New ( ) ; protected : const char * GetClassNameInternal ( ) const override { return thisClass ; } public : typedef vtkPolyDataAlgorithm Superclass ; static vtkTypeBool IsTypeOf ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 1 ; } return vtkPolyDataAlgorithm :: IsTypeOf ( type ) ; } vtkTypeBool IsA ( const char * type ) override { return this -> vtkPTSReader :: IsTypeOf ( type ) ; } static vtkPTSReader * SafeDownCast ( vtkObjectBase * o ) { if ( o && o -> IsA ( thisClass ) ) { return static_cast < vtkPTSReader * > ( o ) ; } return nullptr ; } VTK_NEWINSTANCE vtkPTSReader * NewInstance ( ) const { return vtkPTSReader :: SafeDownCast ( this -> NewInstanceInternal ( ) ) ; } static vtkIdType GetNumberOfGenerationsFromBaseType ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 0 ; } return 1 + vtkPolyDataAlgorithm :: GetNumberOfGenerationsFromBaseType ( type ) ; } vtkIdType GetNumberOfGenerationsFromBase ( const char * type ) override { return this -> vtkPTSReader :: GetNumberOfGenerationsFromBaseType ( type ) ; } public : protected : vtkObjectBase * NewInstanceInternal ( ) const override { return vtkPTSReader :: New ( ) ; } public : ; void PrintSelf ( ostream & os , vtkIndent indent ) override ; /@{ *
##  Specify file name.
##  void SetFileName ( VTK_FILEPATH const char * filename ) ; virtual VTK_FILEPATH VTK_FUTURE_CONST char * GetFileName ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << FileName  of  << ( this -> FileName ? this -> FileName : (null) ) ) ; return this -> FileName ; } ; /@} /@{ *
##  Boolean value indicates whether or not to limit points read to a specified
##  (ReadBounds) region.
##  virtual void LimitReadToBoundsOn ( ) { this -> SetLimitReadToBounds ( static_cast < bool > ( 1 ) ) ; } virtual void LimitReadToBoundsOff ( ) { this -> SetLimitReadToBounds ( static_cast < bool > ( 0 ) ) ; } ; virtual void SetLimitReadToBounds ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  LimitReadToBounds  to  << _arg ) ; if ( this -> LimitReadToBounds != _arg ) { this -> LimitReadToBounds = _arg ; this -> Modified ( ) ; } } ; virtual bool GetLimitReadToBounds ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << LimitReadToBounds  of  << this -> LimitReadToBounds ) ; return this -> LimitReadToBounds ; } ; /@} /@{ *
##  Bounds to use if LimitReadToBounds is On
##  virtual void SetReadBounds ( double _arg1 , double _arg2 , double _arg3 , double _arg4 , double _arg5 , double _arg6 ) { vtkDebugWithObjectMacro ( this , <<  setting  << ReadBounds  to ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << , << _arg5 << , << _arg6 << ) ) ; if ( ( this -> ReadBounds [ 0 ] != _arg1 ) || ( this -> ReadBounds [ 1 ] != _arg2 ) || ( this -> ReadBounds [ 2 ] != _arg3 ) || ( this -> ReadBounds [ 3 ] != _arg4 ) || ( this -> ReadBounds [ 4 ] != _arg5 ) || ( this -> ReadBounds [ 5 ] != _arg6 ) ) { this -> ReadBounds [ 0 ] = _arg1 ; this -> ReadBounds [ 1 ] = _arg2 ; this -> ReadBounds [ 2 ] = _arg3 ; this -> ReadBounds [ 3 ] = _arg4 ; this -> ReadBounds [ 4 ] = _arg5 ; this -> ReadBounds [ 5 ] = _arg6 ; this -> Modified ( ) ; } } virtual void SetReadBounds ( const double _arg [ 6 ] ) { this -> SetReadBounds ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] , _arg [ 4 ] , _arg [ 5 ] ) ; } ; virtual double * GetReadBounds ( ) VTK_SIZEHINT ( 6 ) { vtkDebugWithObjectMacro ( this , <<  returning  << ReadBounds  pointer  << this -> ReadBounds ) ; return this -> ReadBounds ; } VTK_WRAPEXCLUDE virtual void GetReadBounds ( double & _arg1 , double & _arg2 , double & _arg3 , double & _arg4 , double & _arg5 , double & _arg6 ) { _arg1 = this -> ReadBounds [ 0 ] ; _arg2 = this -> ReadBounds [ 1 ] ; _arg3 = this -> ReadBounds [ 2 ] ; _arg4 = this -> ReadBounds [ 3 ] ; _arg5 = this -> ReadBounds [ 4 ] ; _arg6 = this -> ReadBounds [ 5 ] ; vtkDebugWithObjectMacro ( this , <<  returning  << ReadBounds  = ( << _arg1 << , << _arg2 << , << _arg3 << , << _arg4 << , << _arg5 << , << _arg6 << ) ) ; } VTK_WRAPEXCLUDE virtual void GetReadBounds ( double _arg [ 6 ] ) { this -> GetReadBounds ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] , _arg [ 3 ] , _arg [ 4 ] , _arg [ 5 ] ) ; } ; /@} /@{ *
##  The output type defaults to float, but can instead be double.
##  virtual void OutputDataTypeIsDoubleOn ( ) { this -> SetLimitReadToBoundsOutputDataTypeIsDouble ( static_cast < bool > ( 1 ) ) ; } virtual void OutputDataTypeIsDoubleOff ( ) { this -> SetLimitReadToBoundsOutputDataTypeIsDouble ( static_cast < bool > ( 0 ) ) ; } ; virtual void SetLimitReadToBoundsOutputDataTypeIsDouble ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  OutputDataTypeIsDouble  to  << _arg ) ; if ( this -> OutputDataTypeIsDouble != _arg ) { this -> OutputDataTypeIsDouble = _arg ; this -> Modified ( ) ; } } ; virtual bool GetLimitReadToBoundsOutputDataTypeIsDouble ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << OutputDataTypeIsDouble  of  << this -> OutputDataTypeIsDouble ) ; return this -> OutputDataTypeIsDouble ; } ; /@} /@{ *
##  Boolean value indicates whether or not to limit number of points read
##  based on MaxNumbeOfPoints.
##  virtual void LimitToMaxNumberOfPointsOn ( ) { this -> SetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPoints ( static_cast < bool > ( 1 ) ) ; } virtual void LimitToMaxNumberOfPointsOff ( ) { this -> SetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPoints ( static_cast < bool > ( 0 ) ) ; } ; virtual void SetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPoints ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  LimitToMaxNumberOfPoints  to  << _arg ) ; if ( this -> LimitToMaxNumberOfPoints != _arg ) { this -> LimitToMaxNumberOfPoints = _arg ; this -> Modified ( ) ; } } ; virtual bool GetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPoints ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << LimitToMaxNumberOfPoints  of  << this -> LimitToMaxNumberOfPoints ) ; return this -> LimitToMaxNumberOfPoints ; } ; /@} /@{ *
##  The maximum number of points to load if LimitToMaxNumberOfPoints is on/true.
##  Sets a temporary onRatio.
##  virtual void SetMaxNumberOfPoints ( vtkIdType _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << MaxNumberOfPoints  to  << _arg ) ; if ( this -> MaxNumberOfPoints != ( _arg < 1 ? 1 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ) { this -> MaxNumberOfPoints = ( _arg < 1 ? 1 : ( _arg > VTK_INT_MAX ? VTK_INT_MAX : _arg ) ) ; this -> Modified ( ) ; } } virtual vtkIdType GetMaxNumberOfPointsMinValue ( ) { return 1 ; } virtual vtkIdType GetMaxNumberOfPointsMaxValue ( ) { return VTK_INT_MAX ; } ; virtual vtkIdType GetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPointsMaxNumberOfPoints ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << MaxNumberOfPoints  of  << this -> MaxNumberOfPoints ) ; return this -> MaxNumberOfPoints ; } ; /@} /@{ *
##  Boolean value indicates whether or not to create cells
##  for this dataset. Otherwise only points and scalars
##  are created. Defaults to true.
##  virtual void CreateCellsOn ( ) { this -> SetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPointsCreateCells ( static_cast < bool > ( 1 ) ) ; } virtual void CreateCellsOff ( ) { this -> SetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPointsCreateCells ( static_cast < bool > ( 0 ) ) ; } ; virtual void SetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPointsCreateCells ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  CreateCells  to  << _arg ) ; if ( this -> CreateCells != _arg ) { this -> CreateCells = _arg ; this -> Modified ( ) ; } } ; virtual bool GetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPointsMaxNumberOfPointsCreateCells ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << CreateCells  of  << this -> CreateCells ) ; return this -> CreateCells ; } ; /@} /@{ *
##  Boolean value indicates when color values are present
##  if luminance should be read in as well
##  Defaults to true.
##  virtual void IncludeColorAndLuminanceOn ( ) { this -> SetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPointsCreateCellsIncludeColorAndLuminance ( static_cast < bool > ( 1 ) ) ; } virtual void IncludeColorAndLuminanceOff ( ) { this -> SetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPointsCreateCellsIncludeColorAndLuminance ( static_cast < bool > ( 0 ) ) ; } ; virtual void SetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPointsCreateCellsIncludeColorAndLuminance ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  IncludeColorAndLuminance  to  << _arg ) ; if ( this -> IncludeColorAndLuminance != _arg ) { this -> IncludeColorAndLuminance = _arg ; this -> Modified ( ) ; } } ; virtual bool GetLimitReadToBoundsOutputDataTypeIsDoubleLimitToMaxNumberOfPointsMaxNumberOfPointsCreateCellsIncludeColorAndLuminance ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << IncludeColorAndLuminance  of  << this -> IncludeColorAndLuminance ) ; return this -> IncludeColorAndLuminance ; } ; /@} protected : vtkPTSReader ( ) ; ~ vtkPTSReader ( ) override ; int RequestInformation ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; int RequestData ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; char * FileName ; bool OutputDataTypeIsDouble ; bool LimitReadToBounds ; double ReadBounds [ 6 ] ; vtkBoundingBox ReadBBox ; bool LimitToMaxNumberOfPoints ; vtkIdType MaxNumberOfPoints ; bool CreateCells ; bool IncludeColorAndLuminance ; private : vtkPTSReader ( const vtkPTSReader & ) = delete ; void operator = ( const vtkPTSReader & ) = delete ; } ;
## Error: token expected: ; but got: [identifier]!!!
