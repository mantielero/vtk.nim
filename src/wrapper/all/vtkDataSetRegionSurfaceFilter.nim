## =========================================================================
##   Copyright (c) Kitware, Inc.
##   All rights reserved.
##   See LICENSE.txt for details.
##
##   This software is distributed WITHOUT ANY WARRANTY; without even
##   the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##   PURPOSE.  See the above copyright notice for more information.
## =========================================================================
## *
##  @class   vtkDataSetRegionSurfaceFilter
##  @brief   Extract surface of materials.
##
##  This filter extracts surfaces of materials such that a surface
##  could have a material on each side of it. It also stores a
##  mapping of the original cells and their sides back to the original grid
##  so that we can output boundary information for those cells given
##  only surfaces.
##

## !!!Ignored construct:  # vtkDataSetRegionSurfaceFilter_h [NewLine] # vtkDataSetRegionSurfaceFilter_h [NewLine] # vtkFiltersGeometryModule.h  For export macro [NewLine] # vtkDataSetSurfaceFilter.h [NewLine] class vtkCharArray ;
## Error: token expected: ; but got: [identifier]!!!

## !!!Ignored construct:  class VTKFILTERSGEOMETRY_EXPORT vtkDataSetRegionSurfaceFilter : public vtkDataSetSurfaceFilter { public : static vtkDataSetRegionSurfaceFilter * New ( ) ; protected : const char * GetClassNameInternal ( ) const override { return thisClass ; } public : typedef vtkDataSetSurfaceFilter Superclass ; static vtkTypeBool IsTypeOf ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 1 ; } return vtkDataSetSurfaceFilter :: IsTypeOf ( type ) ; } vtkTypeBool IsA ( const char * type ) override { return this -> vtkDataSetRegionSurfaceFilter :: IsTypeOf ( type ) ; } static vtkDataSetRegionSurfaceFilter * SafeDownCast ( vtkObjectBase * o ) { if ( o && o -> IsA ( thisClass ) ) { return static_cast < vtkDataSetRegionSurfaceFilter * > ( o ) ; } return nullptr ; } VTK_NEWINSTANCE vtkDataSetRegionSurfaceFilter * NewInstance ( ) const { return vtkDataSetRegionSurfaceFilter :: SafeDownCast ( this -> NewInstanceInternal ( ) ) ; } static vtkIdType GetNumberOfGenerationsFromBaseType ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 0 ; } return 1 + vtkDataSetSurfaceFilter :: GetNumberOfGenerationsFromBaseType ( type ) ; } vtkIdType GetNumberOfGenerationsFromBase ( const char * type ) override { return this -> vtkDataSetRegionSurfaceFilter :: GetNumberOfGenerationsFromBaseType ( type ) ; } public : protected : vtkObjectBase * NewInstanceInternal ( ) const override { return vtkDataSetRegionSurfaceFilter :: New ( ) ; } public : ; void PrintSelf ( ostream & os , vtkIndent indent ) override ; /@{ *
##  The name of the cell based array that we use to extract interfaces from
##  Default is "Regions"
##  virtual void SetRegionArrayName ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << RegionArrayName  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> RegionArrayName == nullptr && _arg == nullptr ) { return ; } if ( this -> RegionArrayName && _arg && ( ! strcmp ( this -> RegionArrayName , _arg ) ) ) { return ; } delete [ ] this -> RegionArrayName ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> RegionArrayName = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> RegionArrayName = nullptr ; } this -> Modified ( ) ; } ; virtual char * GetRegionArrayName ( ) { vtkDebugWithObjectMacro ( this , <<  returning  << RegionArrayName  of  << ( this -> RegionArrayName ? this -> RegionArrayName : (null) ) ) ; return this -> RegionArrayName ; } ; /@} int UnstructuredGridExecute ( vtkDataSet * input , vtkPolyData * output ) override ;  make it clear we want all the recordOrigCellId signatures from our parent using vtkDataSetSurfaceFilter :: RecordOrigCellId ;  override one of the signatures void RecordOrigCellId ( vtkIdType newIndex , vtkFastGeomQuad * quad ) override ; /@{ *
##  Whether to return single sided material interfaces or double sided
##  Default is single
##  virtual void SetSingleSided ( bool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  SingleSided  to  << _arg ) ; if ( this -> SingleSided != _arg ) { this -> SingleSided = _arg ; this -> Modified ( ) ; } } ; virtual bool GetSingleSided ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << SingleSided  of  << this -> SingleSided ) ; return this -> SingleSided ; } ; /@} /@{ *
##  The name of the field array that has characteristics of each material
##  Default is "material_properties"
##  virtual void SetRegionArrayNameMaterialPropertiesName ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << MaterialPropertiesName  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> MaterialPropertiesName == nullptr && _arg == nullptr ) { return ; } if ( this -> MaterialPropertiesName && _arg && ( ! strcmp ( this -> MaterialPropertiesName , _arg ) ) ) { return ; } delete [ ] this -> MaterialPropertiesName ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> MaterialPropertiesName = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> MaterialPropertiesName = nullptr ; } this -> Modified ( ) ; } ; virtual char * GetRegionArrayNameMaterialPropertiesName ( ) { vtkDebugWithObjectMacro ( this , <<  returning  << MaterialPropertiesName  of  << ( this -> MaterialPropertiesName ? this -> MaterialPropertiesName : (null) ) ) ; return this -> MaterialPropertiesName ; } ; /@} /@{ *
##  The name of the field array that has material type identifiers in it
##  Default is "material_ids"
##  virtual void SetRegionArrayNameMaterialPropertiesNameMaterialIDsName ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << MaterialIDsName  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> MaterialIDsName == nullptr && _arg == nullptr ) { return ; } if ( this -> MaterialIDsName && _arg && ( ! strcmp ( this -> MaterialIDsName , _arg ) ) ) { return ; } delete [ ] this -> MaterialIDsName ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> MaterialIDsName = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> MaterialIDsName = nullptr ; } this -> Modified ( ) ; } ; virtual char * GetRegionArrayNameMaterialPropertiesNameMaterialIDsName ( ) { vtkDebugWithObjectMacro ( this , <<  returning  << MaterialIDsName  of  << ( this -> MaterialIDsName ? this -> MaterialIDsName : (null) ) ) ; return this -> MaterialIDsName ; } ; /@} /@{ *
##  The name of the output field array that records parent materials of each interface
##  Default is "material_ancestors"
##  virtual void SetRegionArrayNameMaterialPropertiesNameMaterialIDsNameMaterialPIDsName ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << MaterialPIDsName  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> MaterialPIDsName == nullptr && _arg == nullptr ) { return ; } if ( this -> MaterialPIDsName && _arg && ( ! strcmp ( this -> MaterialPIDsName , _arg ) ) ) { return ; } delete [ ] this -> MaterialPIDsName ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> MaterialPIDsName = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> MaterialPIDsName = nullptr ; } this -> Modified ( ) ; } ; virtual char * GetRegionArrayNameMaterialPropertiesNameMaterialIDsNameMaterialPIDsName ( ) { vtkDebugWithObjectMacro ( this , <<  returning  << MaterialPIDsName  of  << ( this -> MaterialPIDsName ? this -> MaterialPIDsName : (null) ) ) ; return this -> MaterialPIDsName ; } ; /@} /@{ *
##  The name of the field array that has material interface type identifiers in it
##  Default is "interface_ids"
##  virtual void SetRegionArrayNameMaterialPropertiesNameMaterialIDsNameMaterialPIDsNameInterfaceIDsName ( const char * _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << InterfaceIDsName  to  << ( _arg ? _arg : (null) ) ) ; if ( this -> InterfaceIDsName == nullptr && _arg == nullptr ) { return ; } if ( this -> InterfaceIDsName && _arg && ( ! strcmp ( this -> InterfaceIDsName , _arg ) ) ) { return ; } delete [ ] this -> InterfaceIDsName ; if ( _arg ) { size_t n = strlen ( _arg ) + 1 ; char * cp1 = new char [ n ] ; const char * cp2 = ( _arg ) ; this -> InterfaceIDsName = cp1 ; do { * cp1 ++ = * cp2 ++ ; } while ( -- n ) ; } else { this -> InterfaceIDsName = nullptr ; } this -> Modified ( ) ; } ; virtual char * GetRegionArrayNameMaterialPropertiesNameMaterialIDsNameMaterialPIDsNameInterfaceIDsName ( ) { vtkDebugWithObjectMacro ( this , <<  returning  << InterfaceIDsName  of  << ( this -> InterfaceIDsName ? this -> InterfaceIDsName : (null) ) ) ; return this -> InterfaceIDsName ; } ; /@} protected : vtkDataSetRegionSurfaceFilter ( ) ; ~ vtkDataSetRegionSurfaceFilter ( ) override ; int FillInputPortInformation ( int port , vtkInformation * info ) override ; / Implementation of the algorithm. int RequestData ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; virtual void InsertQuadInHash ( vtkIdType a , vtkIdType b , vtkIdType c , vtkIdType d , vtkIdType sourceId , vtkIdType faceId ) ; void InsertQuadInHash ( vtkIdType a , vtkIdType b , vtkIdType c , vtkIdType d , vtkIdType sourceId ) override { this -> InsertQuadInHash ( a , b , c , d , sourceId , - 1 ) ;  for -Woverloaded-virtual comp warning } void InsertTriInHash ( vtkIdType a , vtkIdType b , vtkIdType c , vtkIdType sourceId , vtkIdType faceId ) override ; virtual void InsertTriInHash ( vtkIdType a , vtkIdType b , vtkIdType c , vtkIdType sourceId ) { this -> InsertTriInHash ( a , b , c , sourceId , - 1 ) ;  for -Woverloaded-virtual comp warning } virtual vtkFastGeomQuad * GetNextVisibleQuadFromHash ( ) ; private : vtkDataSetRegionSurfaceFilter ( const vtkDataSetRegionSurfaceFilter & ) = delete ; void operator = ( const vtkDataSetRegionSurfaceFilter & ) = delete ; char * RegionArrayName ; vtkIntArray * RegionArray ; vtkIdTypeArray * OrigCellIds ; vtkCharArray * CellFaceIds ; bool SingleSided ; char * MaterialPropertiesName ; char * MaterialIDsName ; char * MaterialPIDsName ; char * InterfaceIDsName ; class Internals ; Internals * Internal ; } ;
## Error: token expected: ; but got: [identifier]!!!
