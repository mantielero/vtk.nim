## =========================================================================
##
##   Program:   Visualization Toolkit
##   Module:    vtkLinearExtrusionFilter.h
##
##   Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
##   All rights reserved.
##   See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
##
##      This software is distributed WITHOUT ANY WARRANTY; without even
##      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##      PURPOSE.  See the above copyright notice for more information.
##
## =========================================================================
## *
##  @class   vtkLinearExtrusionFilter
##  @brief   sweep polygonal data creating a "skirt" from free edges and lines, and lines from
##  vertices
##
##  vtkLinearExtrusionFilter is a modeling filter. It takes polygonal data as
##  input and generates polygonal data on output. The input dataset is swept
##  according to some extrusion function and creates new polygonal primitives.
##  These primitives form a "skirt" or swept surface. For example, sweeping a
##  line results in a quadrilateral, and sweeping a triangle creates a "wedge".
##
##  There are a number of control parameters for this filter. You can
##  control whether the sweep of a 2D object (i.e., polygon or triangle strip)
##  is capped with the generating geometry via the "Capping" ivar. Also, you
##  can extrude in the direction of a user specified vector, towards a point,
##  or in the direction of vertex normals (normals must be provided - use
##  vtkPolyDataNormals if necessary). The amount of extrusion is controlled by
##  the "ScaleFactor" instance variable.
##
##  The skirt is generated by locating certain topological features. Free
##  edges (edges of polygons or triangle strips only used by one polygon or
##  triangle strips) generate surfaces. This is true also of lines or
##  polylines. Vertices generate lines.
##
##  This filter can be used to create 3D fonts, 3D irregular bar charts,
##  or to model 2 1/2D objects like punched plates. It also can be used to
##  create solid objects from 2D polygonal meshes.
##
##  @warning
##  Some polygonal objects have no free edges (e.g., sphere). When swept,
##  this will result in two separate surfaces if capping is on, or no surface
##  if capping is off.
##
##  @sa
##  vtkRotationalExtrusionFilter
##

## !!!Ignored construct:  # vtkLinearExtrusionFilter_h [NewLine] # vtkLinearExtrusionFilter_h [NewLine] # vtkFiltersModelingModule.h  For export macro # vtkPolyDataAlgorithm.h [NewLine] class vtkDataArray ;
## Error: token expected: ; but got: [identifier]!!!

const
  VTK_VECTOR_EXTRUSION* = 1
  VTK_NORMAL_EXTRUSION* = 2
  VTK_POINT_EXTRUSION* = 3

## !!!Ignored construct:  class VTKFILTERSMODELING_EXPORT vtkLinearExtrusionFilter : public vtkPolyDataAlgorithm { public : protected : const char * GetClassNameInternal ( ) const override { return thisClass ; } public : typedef vtkPolyDataAlgorithm Superclass ; static vtkTypeBool IsTypeOf ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 1 ; } return vtkPolyDataAlgorithm :: IsTypeOf ( type ) ; } vtkTypeBool IsA ( const char * type ) override { return this -> vtkLinearExtrusionFilter :: IsTypeOf ( type ) ; } static vtkLinearExtrusionFilter * SafeDownCast ( vtkObjectBase * o ) { if ( o && o -> IsA ( thisClass ) ) { return static_cast < vtkLinearExtrusionFilter * > ( o ) ; } return nullptr ; } VTK_NEWINSTANCE vtkLinearExtrusionFilter * NewInstance ( ) const { return vtkLinearExtrusionFilter :: SafeDownCast ( this -> NewInstanceInternal ( ) ) ; } static vtkIdType GetNumberOfGenerationsFromBaseType ( const char * type ) { if ( ! strcmp ( thisClass , type ) ) { return 0 ; } return 1 + vtkPolyDataAlgorithm :: GetNumberOfGenerationsFromBaseType ( type ) ; } vtkIdType GetNumberOfGenerationsFromBase ( const char * type ) override { return this -> vtkLinearExtrusionFilter :: GetNumberOfGenerationsFromBaseType ( type ) ; } public : protected : vtkObjectBase * NewInstanceInternal ( ) const override { return vtkLinearExtrusionFilter :: New ( ) ; } public : ; void PrintSelf ( ostream & os , vtkIndent indent ) override ; *
##  Create object with normal extrusion type, capping on, scale factor=1.0,
##  vector (0,0,1), and extrusion point (0,0,0).
##  static vtkLinearExtrusionFilter * New ( ) ; /@{ *
##  Set/Get the type of extrusion.
##  virtual void SetExtrusionType ( int _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  << ExtrusionType  to  << _arg ) ; if ( this -> ExtrusionType != ( _arg < VTK_VECTOR_EXTRUSION ? VTK_VECTOR_EXTRUSION : ( _arg > VTK_POINT_EXTRUSION ? VTK_POINT_EXTRUSION : _arg ) ) ) { this -> ExtrusionType = ( _arg < VTK_VECTOR_EXTRUSION ? VTK_VECTOR_EXTRUSION : ( _arg > VTK_POINT_EXTRUSION ? VTK_POINT_EXTRUSION : _arg ) ) ; this -> Modified ( ) ; } } virtual int GetExtrusionTypeMinValue ( ) { return VTK_VECTOR_EXTRUSION ; } virtual int GetExtrusionTypeMaxValue ( ) { return VTK_POINT_EXTRUSION ; } ; virtual int GetExtrusionType ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ExtrusionType  of  << this -> ExtrusionType ) ; return this -> ExtrusionType ; } ; void SetExtrusionTypeToVectorExtrusion ( ) { this -> SetExtrusionType ( VTK_VECTOR_EXTRUSION ) ; } void SetExtrusionTypeToNormalExtrusion ( ) { this -> SetExtrusionType ( VTK_NORMAL_EXTRUSION ) ; } void SetExtrusionTypeToPointExtrusion ( ) { this -> SetExtrusionType ( VTK_POINT_EXTRUSION ) ; } /@} /@{ *
##  Turn on/off the capping of the skirt.
##  virtual void SetCapping ( vtkTypeBool _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  Capping  to  << _arg ) ; if ( this -> Capping != _arg ) { this -> Capping = _arg ; this -> Modified ( ) ; } } ; virtual vtkTypeBool GetExtrusionTypeCapping ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << Capping  of  << this -> Capping ) ; return this -> Capping ; } ; virtual void CappingOn ( ) { this -> SetCapping ( static_cast < vtkTypeBool > ( 1 ) ) ; } virtual void CappingOff ( ) { this -> SetCapping ( static_cast < vtkTypeBool > ( 0 ) ) ; } ; /@} /@{ *
##  Set/Get extrusion scale factor,
##  virtual void SetCappingScaleFactor ( double _arg ) { vtkDebugWithObjectMacro ( this , <<  setting  ScaleFactor  to  << _arg ) ; if ( this -> ScaleFactor != _arg ) { this -> ScaleFactor = _arg ; this -> Modified ( ) ; } } ; virtual double GetExtrusionTypeCappingScaleFactor ( ) VTK_FUTURE_CONST { vtkDebugWithObjectMacro ( this , <<  returning  << ScaleFactor  of  << this -> ScaleFactor ) ; return this -> ScaleFactor ; } ; /@} /@{ *
##  Set/Get extrusion vector. Only needs to be set if VectorExtrusion is
##  turned on.
##  virtual void SetVector ( double _arg1 , double _arg2 , double _arg3 ) { vtkDebugWithObjectMacro ( this , <<  setting  << Vector  to ( << _arg1 << , << _arg2 << , << _arg3 << ) ) ; if ( ( this -> Vector [ 0 ] != _arg1 ) || ( this -> Vector [ 1 ] != _arg2 ) || ( this -> Vector [ 2 ] != _arg3 ) ) { this -> Vector [ 0 ] = _arg1 ; this -> Vector [ 1 ] = _arg2 ; this -> Vector [ 2 ] = _arg3 ; this -> Modified ( ) ; } } virtual void SetVector ( const double _arg [ 3 ] ) { this -> SetVector ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] ) ; } ; virtual double * GetVector ( ) VTK_SIZEHINT ( 3 ) { vtkDebugWithObjectMacro ( this , <<  returning  << Vector  pointer  << this -> Vector ) ; return this -> Vector ; } VTK_WRAPEXCLUDE virtual void GetVector ( double data [ 3 ] ) { for ( int i = 0 ; i < 3 ; i ++ ) { data [ i ] = this -> Vector [ i ] ; } } ; /@} /@{ *
##  Set/Get extrusion point. Only needs to be set if PointExtrusion is
##  turned on. This is the point towards which extrusion occurs.
##  virtual void SetVectorExtrusionPoint ( double _arg1 , double _arg2 , double _arg3 ) { vtkDebugWithObjectMacro ( this , <<  setting  << ExtrusionPoint  to ( << _arg1 << , << _arg2 << , << _arg3 << ) ) ; if ( ( this -> ExtrusionPoint [ 0 ] != _arg1 ) || ( this -> ExtrusionPoint [ 1 ] != _arg2 ) || ( this -> ExtrusionPoint [ 2 ] != _arg3 ) ) { this -> ExtrusionPoint [ 0 ] = _arg1 ; this -> ExtrusionPoint [ 1 ] = _arg2 ; this -> ExtrusionPoint [ 2 ] = _arg3 ; this -> Modified ( ) ; } } virtual void SetVectorExtrusionPoint ( const double _arg [ 3 ] ) { this -> SetVectorExtrusionPoint ( _arg [ 0 ] , _arg [ 1 ] , _arg [ 2 ] ) ; } ; virtual double * GetVectorExtrusionPoint ( ) VTK_SIZEHINT ( 3 ) { vtkDebugWithObjectMacro ( this , <<  returning  << ExtrusionPoint  pointer  << this -> ExtrusionPoint ) ; return this -> ExtrusionPoint ; } VTK_WRAPEXCLUDE virtual void GetVectorExtrusionPoint ( double data [ 3 ] ) { for ( int i = 0 ; i < 3 ; i ++ ) { data [ i ] = this -> ExtrusionPoint [ i ] ; } } ; /@} protected : vtkLinearExtrusionFilter ( ) ; ~ vtkLinearExtrusionFilter ( ) override = default ; int RequestData ( vtkInformation * , vtkInformationVector * * , vtkInformationVector * ) override ; int ExtrusionType ; vtkTypeBool Capping ; double ScaleFactor ; double Vector [ 3 ] ; double ExtrusionPoint [ 3 ] ; void ( vtkLinearExtrusionFilter :: * ExtrudePoint ) ( double x [ 3 ] , vtkIdType id , vtkDataArray * normals ) ; void ViaNormal ( double x [ 3 ] , vtkIdType id , vtkDataArray * normals ) ; void ViaVector ( double x [ 3 ] , vtkIdType id , vtkDataArray * normals = nullptr ) ; void ViaPoint ( double x [ 3 ] , vtkIdType id , vtkDataArray * normals = nullptr ) ; private : vtkLinearExtrusionFilter ( const vtkLinearExtrusionFilter & ) = delete ; void operator = ( const vtkLinearExtrusionFilter & ) = delete ; } ;
## Error: token expected: ; but got: [identifier]!!!
