## =========================================================================
##
##   Program:   Visualization Toolkit
##   Module:    vtkJavaAwt.h
##
##   Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
##   All rights reserved.
##   See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
##
##      This software is distributed WITHOUT ANY WARRANTY; without even
##      the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
##      PURPOSE.  See the above copyright notice for more information.
##
## =========================================================================

## !!!Ignored construct:  # vtkJavaAwt_h [NewLine] # vtkJavaAwt_h [NewLine]  for use with JAWT # jawt_md.h [NewLine] # [NewLine]  On OS X, disable deprecation warnings since JAWT_GetAWT() is deprecated. # defined ( __APPLE__ ) && defined ( __GNUC__ ) [NewLine] # GCC diagnostic push [NewLine] # GCC diagnostic ignored -Wdeprecated-declarations [NewLine] # [NewLine] # defined ( _WIN32 ) [NewLine] # [NewLine] # [NewLine] # defined ( ) [NewLine] # WJLH_MAX_COUNT ( 32 ) [NewLine] # WJLH_HASH_FUNC ( E , C , H ) { jclass cls = E -> GetObjectClass ( C ) ; jmethodID mid = E -> GetMethodID ( cls , hashCode , ()I ) ; H = E -> CallIntMethod ( C , mid ) ; } [NewLine] # vtkWindows.h [NewLine] int WJLH_init_check = 0 ;
## Error: did not expect [NewLine]!!!

var WJLH_lock_map* {.importcpp: "WJLH_lock_map", header: "vtkJavaAwt.h".}: map[cint,
    cint]

## !!!Ignored construct:  [NewLine] # [NewLine] extern C JNIEXPORT jint JNICALL Java_vtk_vtkPanel_RenderCreate ( JNIEnv * env , jobject canvas , jobject id0 ) { # defined ( ) [NewLine] int hash ; WJLH_HASH_FUNC ( env , canvas , hash ) ; WJLH_lock_map [ hash ] = 0 ; # [NewLine] JAWT awt ; JAWT_DrawingSurface * ds ; JAWT_DrawingSurfaceInfo * dsi ; jint lock ;  get the render window pointer vtkRenderWindow * temp0 ; temp0 = ( vtkRenderWindow * ) ( vtkJavaGetPointerFromObject ( env , id0 ) ) ;  Get the AWT awt . version = JAWT_VERSION_1_3 ; if ( JAWT_GetAWT ( env , & awt ) == JNI_FALSE ) { # [NewLine] printf ( AWT Not found
##  ) ; # [NewLine] return 1 ; }  Get the drawing surface ds = awt . GetDrawingSurface ( env , canvas ) ; if ( ds == NULL ) { # [NewLine] printf ( NULL drawing surface
##  ) ; # [NewLine] return 1 ; }  Lock the drawing surface lock = ds -> Lock ( ds ) ; if ( ( lock & JAWT_LOCK_ERROR ) != 0 ) { # [NewLine] printf ( Error locking surface
##  ) ; # [NewLine] awt . FreeDrawingSurface ( ds ) ; return 1 ; }  Get the drawing surface info dsi = ds -> GetDrawingSurfaceInfo ( ds ) ; if ( dsi == NULL ) { printf ( Error getting surface info
##  ) ; ds -> Unlock ( ds ) ; awt . FreeDrawingSurface ( ds ) ; return 1 ; }  Here is the win32 drawing code # defined ( _WIN32 ) [NewLine] temp0 -> Finalize ( ) ; JAWT_Win32DrawingSurfaceInfo * dsi_win ; dsi_win = ( JAWT_Win32DrawingSurfaceInfo * ) dsi -> platformInfo ; temp0 -> SetWindowId ( ( void * ) dsi_win -> hwnd ) ; temp0 -> SetDisplayId ( ( void * ) dsi_win -> hdc ) ;  also set parent id to avoid border sizes being added temp0 -> SetParentId ( ( void * ) dsi_win -> hdc ) ;  use mac code # defined ( __APPLE__ ) [NewLine] JAWT_DrawingSurfaceInfo * dsi_mac ; dsi_mac = ( JAWT_DrawingSurfaceInfo * ) dsi -> platformInfo ;  temp0->SetWindowId(dsi_mac->cocoaViewRef); // Wrong but allow compilation  otherwise use X11 code # [NewLine] JAWT_X11DrawingSurfaceInfo * dsi_x11 ; dsi_x11 = ( JAWT_X11DrawingSurfaceInfo * ) dsi -> platformInfo ; temp0 -> SetDisplayId ( ( void * ) dsi_x11 -> display ) ; temp0 -> SetWindowId ( ( void * ) dsi_x11 -> drawable ) ; temp0 -> SetParentId ( ( void * ) dsi_x11 -> display ) ; # [NewLine]  Free the drawing surface info ds -> FreeDrawingSurfaceInfo ( dsi ) ;  Unlock the drawing surface ds -> Unlock ( ds ) ;  Free the drawing surface awt . FreeDrawingSurface ( ds ) ; # defined ( ) [NewLine] if ( WJLH_init_check == 0 ) { WJLH_init_check = 1 ; } WJLH_lock_map [ hash ] = 1 ; # [NewLine] return 0 ; } extern C JNIEXPORT jint JNICALL Java_vtk_rendering_awt_vtkInternalAwtComponent_RenderCreate ( JNIEnv * env , jobject canvas , jobject id0 ) { # defined ( ) [NewLine] int hash ; WJLH_HASH_FUNC ( env , canvas , hash ) ; WJLH_lock_map [ hash ] = 0 ; # [NewLine] JAWT awt ; JAWT_DrawingSurface * ds ; JAWT_DrawingSurfaceInfo * dsi ; jint lock ;  get the render window pointer vtkRenderWindow * temp0 ; temp0 = ( vtkRenderWindow * ) ( vtkJavaGetPointerFromObject ( env , id0 ) ) ;  Get the AWT awt . version = JAWT_VERSION_1_3 ; if ( JAWT_GetAWT ( env , & awt ) == JNI_FALSE ) { # [NewLine] printf ( AWT Not found
##  ) ; # [NewLine] return 1 ; }  Get the drawing surface ds = awt . GetDrawingSurface ( env , canvas ) ; if ( ds == NULL ) { # [NewLine] printf ( NULL drawing surface
##  ) ; # [NewLine] return 1 ; }  Lock the drawing surface lock = ds -> Lock ( ds ) ; if ( ( lock & JAWT_LOCK_ERROR ) != 0 ) { # [NewLine] printf ( Error locking surface
##  ) ; # [NewLine] awt . FreeDrawingSurface ( ds ) ; return 1 ; }  Get the drawing surface info dsi = ds -> GetDrawingSurfaceInfo ( ds ) ; if ( dsi == NULL ) { printf ( Error getting surface info
##  ) ; ds -> Unlock ( ds ) ; awt . FreeDrawingSurface ( ds ) ; return 1 ; }  Here is the win32 drawing code # defined ( _WIN32 ) [NewLine] temp0 -> Finalize ( ) ; JAWT_Win32DrawingSurfaceInfo * dsi_win ; dsi_win = ( JAWT_Win32DrawingSurfaceInfo * ) dsi -> platformInfo ; temp0 -> SetWindowId ( ( void * ) dsi_win -> hwnd ) ; temp0 -> SetDisplayId ( ( void * ) dsi_win -> hdc ) ;  also set parent id to avoid border sizes being added temp0 -> SetParentId ( ( void * ) dsi_win -> hdc ) ;  use mac code # defined ( __APPLE__ ) [NewLine] JAWT_DrawingSurfaceInfo * dsi_mac ; dsi_mac = ( JAWT_DrawingSurfaceInfo * ) dsi -> platformInfo ;  temp0->SetWindowId(dsi_mac->cocoaViewRef); // Wrong but allow compilation  otherwise use X11 code # [NewLine] JAWT_X11DrawingSurfaceInfo * dsi_x11 ; dsi_x11 = ( JAWT_X11DrawingSurfaceInfo * ) dsi -> platformInfo ; temp0 -> SetDisplayId ( ( void * ) dsi_x11 -> display ) ; temp0 -> SetWindowId ( ( void * ) dsi_x11 -> drawable ) ; temp0 -> SetParentId ( ( void * ) dsi_x11 -> display ) ; # [NewLine]  Free the drawing surface info ds -> FreeDrawingSurfaceInfo ( dsi ) ;  Unlock the drawing surface ds -> Unlock ( ds ) ;  Free the drawing surface awt . FreeDrawingSurface ( ds ) ; # defined ( ) [NewLine] if ( WJLH_init_check == 0 ) { WJLH_init_check = 1 ; } WJLH_lock_map [ hash ] = 1 ; # [NewLine] return 0 ; }  Lock must be called prior to render or anything which might
##  cause vtkRenderWindow to make an XLib call or to call Render().
##  The Lock() and UnLock() functions are necessary for drawing in
##  JAWT, but they also provide a form of mutex locking so that multiple
##  java threads are prevented from accessing X at the same time.  The only
##  requirement JAWT has is that all operations on a JAWT_DrawingSurface
##  MUST be performed from the same thread as the call to GetDrawingSurface. extern C JNIEXPORT jint JNICALL Java_vtk_vtkPanel_Lock ( JNIEnv * env , jobject canvas ) { JAWT awt ; JAWT_DrawingSurface * ds ; jint lock ;  Get the AWT awt . version = JAWT_VERSION_1_3 ; if ( JAWT_GetAWT ( env , & awt ) == JNI_FALSE ) { # [NewLine] printf ( AWT Not found
##  ) ; # [NewLine] return 1 ; }  Get the drawing surface ds = awt . GetDrawingSurface ( env , canvas ) ; if ( ds == NULL ) { # [NewLine] printf ( NULL drawing surface
##  ) ; # [NewLine] return 1 ; } # defined ( ) [NewLine] int hash ; WJLH_HASH_FUNC ( env , canvas , hash ) ; if ( WJLH_init_check && WJLH_lock_map [ hash ] > WJLH_MAX_COUNT ) { env -> MonitorEnter ( canvas ) ; } else { # [NewLine]  Lock the drawing surface lock = ds -> Lock ( ds ) ; if ( ( lock & JAWT_LOCK_ERROR ) != 0 ) { # [NewLine] printf ( Error locking surface
##  ) ; # [NewLine] awt . FreeDrawingSurface ( ds ) ; return 1 ; } # defined ( ) [NewLine] } # [NewLine] return 0 ; }  UnLock() must be called after a Lock() and execution of a
##  function which might change the drawing surface.  See Lock(). extern C JNIEXPORT jint JNICALL Java_vtk_vtkPanel_UnLock ( JNIEnv * env , jobject canvas ) { JAWT awt ; JAWT_DrawingSurface * ds ;  Get the AWT awt . version = JAWT_VERSION_1_3 ; if ( JAWT_GetAWT ( env , & awt ) == JNI_FALSE ) { # [NewLine] printf ( AWT Not found
##  ) ; # [NewLine] return 1 ; }  Get the drawing surface ds = awt . GetDrawingSurface ( env , canvas ) ; if ( ds == NULL ) { # [NewLine] printf ( NULL drawing surface
##  ) ; # [NewLine] return 1 ; } # defined ( ) [NewLine] int hash ; WJLH_HASH_FUNC ( env , canvas , hash ) ; if ( WJLH_init_check && WJLH_lock_map [ hash ] > WJLH_MAX_COUNT ) { env -> MonitorExit ( canvas ) ; } else { if ( WJLH_init_check ) WJLH_lock_map [ hash ] ++ ; # [NewLine]  Unlock the drawing surface ds -> Unlock ( ds ) ; # defined ( ) [NewLine] } # [NewLine]  Free the drawing surface awt . FreeDrawingSurface ( ds ) ; return 0 ; }  Undo disabling of deprecation warning. # defined ( __APPLE__ ) && defined ( __GNUC__ ) [NewLine] # GCC diagnostic pop [NewLine] # [NewLine] # [NewLine]  VTK-HeaderTest-Exclude: vtkJavaAwt.h
## Error: did not expect [NewLine]!!!
